<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>éº»å°†è®°åˆ† Pro</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #ec4899;
            --bg-light: #f3f4f6;
            --bg-dark: #111827;
            --card-light: rgba(255, 255, 255, 0.8);
            --card-dark: rgba(31, 41, 55, 0.8);
            --text-light: #1f2937;
            --text-dark: #f9fafb;
            --danger: #ef4444;
            --success: #10b981;
            --warning: #f59e0b;
        }

        /* åŸºç¡€é‡ç½® */
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            /* ç§»é™¤ body çš„é»˜è®¤èƒŒæ™¯ï¼Œäº¤ç»™ #app æ¥ç®¡ï¼Œæˆ–è€…è®¾ä¸ºé€æ˜ */
            background: #000; 
            color: var(--text-light);
            transition: color 0.3s;
            height: 100vh;
            /* å°è¯•ä½¿ç”¨ dvh è§£å†³ Safari åº•éƒ¨é®æŒ¡é—®é¢˜ */
            height: 100dvh;
            overflow: hidden;
            user-select: none;
        }
        body.dark {
            color: var(--text-dark);
        }

        /* å¸ƒå±€å®¹å™¨ */
        #app {
            display: flex;
            flex-direction: column;
            height: 100%;
            max-width: 100%;
            margin: 0 auto;
            position: relative;
            /* é»˜è®¤èƒŒæ™¯è‰²åœ¨è¿™é‡Œå®šä¹‰ */
            background: var(--bg-light);
            transition: background 0.3s;
            background-size: cover;
            background-position: center;
        }
        body.dark #app {
            background: var(--bg-dark);
        }

        /* é¡¶éƒ¨æ  */
        .header {
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255,255,255,0.5);
            backdrop-filter: blur(10px);
            z-index: 10;
            /* é€‚é…åˆ˜æµ·å± */
            padding-top: max(12px, env(safe-area-inset-top));
        }
        body.dark .header { background: rgba(0,0,0,0.3); }

        .round-badge {
            background: var(--primary);
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 14px;
            box-shadow: 0 4px 6px -1px rgba(99, 102, 241, 0.4);
            cursor: pointer;
        }

        .header-actions { display: flex; gap: 12px; }
        .icon-btn {
            background: none;
            border: none;
            font-size: 20px;
            color: inherit;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: background 0.2s;
        }
        .icon-btn:hover { background: rgba(0,0,0,0.05); }
        body.dark .icon-btn:hover { background: rgba(255,255,255,0.1); }

        /* æ¸¸æˆåŒºåŸŸ */
        .game-area {
            flex: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        /* ä¸­é—´è½¬ç›˜ */
        .center-dial {
            position: absolute;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: var(--card-light);
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 5;
            transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
            border: 4px solid rgba(255,255,255,0.5);
        }
        body.dark .center-dial {
            background: var(--card-dark);
            border-color: rgba(255,255,255,0.1);
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.5);
        }

        .dial-round { 
            font-size: 36px; /* ç¼©å°å­—å· */
            font-weight: 800; 
            color: var(--primary); 
            line-height: 1;
        }
        
        /* æ–¹å‘æŒ‡ç¤º */
        .direction {
            position: absolute;
            font-size: 20px; /* ç¨å¾®ç¼©å°æ–¹å‘å­—å· */
            font-weight: bold;
            color: #9ca3af;
            transition: color 0.3s;
        }
        /* åªæœ‰ä¸œ(0)æ˜¯çº¢è‰²ï¼Œå…¶ä»–é»˜è®¤ */
        .direction.is-east { color: var(--danger); text-shadow: 0 0 10px rgba(239, 68, 68, 0.5); }
        
        /* å¢åŠ è¾¹è·ï¼Œå¾€å¤–ç§» */
        .dir-0 { bottom: 10px; } 
        .dir-1 { right: 10px; transform: rotate(-90deg); } 
        .dir-2 { top: 10px; transform: rotate(180deg); } 
        .dir-3 { left: 10px; transform: rotate(90deg); }

        /* ç©å®¶å¡ç‰‡ */
        .player-card {
            position: absolute;
            width: 160px;
            padding: 16px;
            background: var(--card-light);
            backdrop-filter: blur(12px);
            border-radius: 20px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: grab;
            border: 2px solid transparent;
            touch-action: none; /* é˜²æ­¢ç§»åŠ¨ç«¯é»˜è®¤è¡Œä¸º */
        }
        body.dark .player-card { background: var(--card-dark); box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3); }
        
        /* æ‹–æ‹½çŠ¶æ€ */
        .player-card.dragging {
            opacity: 0.3;
            cursor: grabbing;
        }
        .player-card.drag-over {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.2);
            box-shadow: 0 0 20px rgba(99, 102, 241, 0.5);
        }
        .player-card.empty-seat {
            cursor: pointer;
        }
        
        /* æ‹–æ‹½åˆ†èº« */
        .drag-clone {
            position: fixed;
            width: 160px;
            padding: 16px;
            background: var(--card-light);
            backdrop-filter: blur(12px);
            border-radius: 20px;
            box-shadow: 0 10px 30px -5px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.2s, transform 0.08s ease-out;
            border: 2px solid var(--primary);
            will-change: transform, left, top;
        }
        body.dark .drag-clone {
            background: var(--card-dark);
        }
        .drag-clone.show {
            opacity: 0.5;
        }
        .drag-clone .player-name {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 4px;
            opacity: 0.8;
        }
        .drag-clone .player-score {
            font-size: 28px;
            font-weight: 800;
            color: var(--primary);
        }
        
        /* ä¸‹ä¸€å±€æ‹–æ‹½åˆ†èº« */
        .drag-clone.next-round-clone {
            background: var(--secondary);
            border-color: var(--secondary);
            color: white;
        }
        body.dark .drag-clone.next-round-clone {
            background: var(--secondary);
            border-color: var(--secondary);
        }
        .drag-clone.next-round-clone .clone-text {
            font-size: 20px;
            font-weight: 700;
            text-align: center;
        }

        /* é’ˆå¯¹ä¸åŒåº§ä½çš„æ—‹è½¬ */
        .pos-1 { transform: translateY(-50%) rotate(-90deg); }
        .pos-2 { transform: rotate(180deg); }
        .pos-3 { transform: translateY(-50%) rotate(90deg); }

        /* æ‹–æ‹½çŠ¶æ€éœ€è¦å åŠ æ—‹è½¬å’Œç¼©æ”¾ */
        .player-card.dragging.pos-0 { transform: scale(1.1); }
        .player-card.dragging.pos-1 { transform: translateY(-50%) rotate(-90deg) scale(1.1); }
        .player-card.dragging.pos-2 { transform: rotate(180deg) scale(1.1); }
        .player-card.dragging.pos-3 { transform: translateY(-50%) rotate(90deg) scale(1.1); }
        
        .player-card.drag-over.pos-0 { transform: scale(1.08); }
        .player-card.drag-over.pos-1 { transform: translateY(-50%) rotate(-90deg) scale(1.08); }
        .player-card.drag-over.pos-2 { transform: rotate(180deg) scale(1.08); }
        .player-card.drag-over.pos-3 { transform: translateY(-50%) rotate(90deg) scale(1.08); }

        /* æ¿€æ´»çŠ¶æ€éœ€è¦å åŠ æ—‹è½¬ */
        .player-card.active.pos-0 { transform: scale(1.05); }
        .player-card.active.pos-1 { transform: translateY(-50%) rotate(-90deg) scale(1.05); }
        .player-card.active.pos-2 { transform: rotate(180deg) scale(1.05); }
        .player-card.active.pos-3 { transform: translateY(-50%) rotate(90deg) scale(1.05); }
        
        .player-card.dealer { border-color: var(--danger); }
        
        /* åº„å®¶æ ‡è®° */
        .dealer-badge {
            position: absolute;
            top: -12px;
            right: -12px;
            width: 32px;
            height: 32px;
            background: var(--danger);
            color: white;
            border-radius: 50%;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            z-index: 2;
            font-weight: 700;
        }

        /* å“åº”å¼å®šä½ä¿®æ­£ */
        .pos-0 { bottom: 20px; }
        .pos-1 { right: -20px; top: 50%; } /* å³ä¾§ç¨å¾®é å¤–ä¸€ç‚¹ï¼Œå› ä¸ºæ—‹è½¬äº† */
        /* ä¿®æ­£ä¸Šæ–¹ç©å®¶ä½ç½®ï¼Œä½¿å…¶ä¸è¾¹ç¼˜è·ç¦»ä¸€è‡´ */
        .pos-2 { top: 20px; } 
        .pos-3 { left: -20px; top: 50%; } /* å·¦ä¾§ç¨å¾®é å¤–ä¸€ç‚¹ */

        /* å¼ºåˆ¶ç«–å±é€»è¾‘ */
        @media screen and (orientation: landscape) {
            body {
                display: flex;
                align-items: center;
                justify-content: center;
                background: #000; /* æ¨ªå±æ—¶èƒŒæ™¯å˜é»‘ï¼Œçªå‡ºä¸­é—´çš„å†…å®¹ */
            }
            
            #app {
                /* å¼ºåˆ¶æ—‹è½¬90åº¦ */
            transform: rotate(-90deg);
                transform-origin: center;
                /* äº¤æ¢å®½é«˜ï¼šå®½åº¦å˜æˆå±å¹•é«˜åº¦ï¼Œé«˜åº¦å˜æˆå±å¹•å®½åº¦ */
                width: 100vh;
                height: 100vw;
                /* é‡æ–°å®šä½ */
                position: absolute;
                overflow: hidden;
                background: var(--bg-light); /* æ¢å¤åº”ç”¨èƒŒæ™¯è‰² */
            }
            
            body.dark #app {
                background: var(--bg-dark);
            }
            
            /* ä¿®å¤æ—‹è½¬åçš„æ¨¡æ€æ¡†æ–¹å‘ï¼Œè®©å®ƒä»¬çœ‹èµ·æ¥æ˜¯æ­£çš„ */
            /* å®é™…ä¸Šæ¨¡æ€æ¡†æ˜¯åœ¨ #app å†…éƒ¨çš„ï¼Œæ‰€ä»¥å®ƒä»¬ä¼šè·Ÿç€ #app ä¸€èµ·è½¬ï¼Œ
               å¯¹äºç”¨æˆ·æ¥è¯´ï¼Œæ‰‹æœºæ¨ªç€æ‹¿ï¼Œçœ‹åˆ°çš„ç”»é¢å°±æ˜¯ç«–ç€çš„ï¼Œæ‰€ä»¥ä¸éœ€è¦é¢å¤–å¤„ç†æ¨¡æ€æ¡†ã€‚
               ç”¨æˆ·éœ€è¦æŠŠæ‰‹æœºç«–è¿‡æ¥ï¼ˆæˆ–è€…å¤´æ­ªè¿‡æ¥ï¼‰æ“ä½œï¼Œè¿™æ­£æ˜¯æˆ‘ä»¬æƒ³è¦çš„æ•ˆæœã€‚
            */
        }

        .player-name { font-size: 16px; font-weight: 600; margin-bottom: 4px; opacity: 0.8; }
        .player-score { font-size: 28px; font-weight: 800; color: var(--primary); }
        .score-diff { font-size: 12px; height: 16px; font-weight: bold; }
        .diff-pos { color: var(--success); }
        .diff-neg { color: var(--danger); }

        /* åº•éƒ¨æ“ä½œæ  */
        .action-bar {
            padding: 20px;
            /* é€‚é…åº•éƒ¨å®‰å…¨åŒºåŸŸ */
            padding-bottom: max(20px, env(safe-area-inset-bottom));
            display: flex;
            gap: 12px;
            justify-content: center;
            background: rgba(255,255,255,0.5);
            backdrop-filter: blur(10px);
            z-index: 10;
        }
        body.dark .action-bar { background: rgba(0,0,0,0.3); }

        .btn {
            padding: 12px 24px;
            border-radius: 12px;
            border: none;
            font-weight: 600;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            /* é˜²æ­¢æ–‡å­—æ¢è¡Œ */
            white-space: nowrap;
        }
        .btn:active { transform: scale(0.96); }
        
        .btn-primary { background: var(--primary); color: white; }
        .btn-primary:hover { background: var(--primary-dark); }
        .btn-secondary { background: white; color: var(--text-light); }
        body.dark .btn-secondary { background: var(--card-dark); color: var(--text-dark); }
        .btn-danger { background: var(--danger); color: white; }
        .btn-warning { background: var(--warning); color: white; }
        
        /* ä¸‹ä¸€å±€æŒ‰é’®æ‹–æ‹½çŠ¶æ€ */
        .next-round-btn {
            cursor: grab;
        }
        .next-round-btn.dragging {
            opacity: 0.3;
            cursor: grabbing;
        }

        /* æ¨¡æ€æ¡† */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(4px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        .modal-overlay.show { opacity: 1; pointer-events: auto; }

        .modal-card {
            background: white;
            width: 90%;
            max-width: 400px;
            border-radius: 24px;
            padding: 24px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
            transform: translateY(20px);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            max-height: 85vh;
            overflow-y: auto;
        }
        body.dark .modal-card { background: #1f2937; border: 1px solid rgba(255,255,255,0.1); }
        .modal-overlay.show .modal-card { transform: translateY(0); }

        .modal-title { font-size: 20px; font-weight: 800; margin-bottom: 20px; text-align: center; }
        
        /* è¾“å…¥æ¡† */
        .input-field {
            width: 100%;
            padding: 12px 16px;
            border-radius: 12px;
            border: 2px solid #e5e7eb;
            background: #f9fafb;
            font-size: 16px;
            margin-bottom: 16px;
            transition: border-color 0.2s;
        }
        body.dark .input-field { background: #374151; border-color: #4b5563; color: white; }
        .input-field:focus { outline: none; border-color: var(--primary); }

        /* åˆ—è¡¨é¡¹ */
        .list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            border-radius: 12px;
            background: #f3f4f6;
            margin-bottom: 8px;
            cursor: pointer;
        }
        body.dark .list-item { background: #374151; }
        .list-item.active { background: var(--primary); color: white; }

        
        /* éª°å­ç›¸å…³æ ·å¼ */
        .center-dial.dice-mode {
            transform: scale(2.5) !important;
            z-index: 101;
            border-color: rgba(255,255,255,0.2);
            background: rgba(40, 40, 60, 0.95);
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.3s, border-color 0.3s;
        }
        
        .center-dial.dice-mode.is-rolling {
            box-shadow: 0 0 40px rgba(239, 68, 68, 0.6) !important;
            border-color: rgba(239, 68, 68, 0.8);
        }
        
        .center-dial.dice-mode.roll-finished {
            box-shadow: 0 0 40px rgba(16, 185, 129, 0.6) !important;
            border-color: rgba(16, 185, 129, 0.8);
        }

        body.dark .center-dial.dice-mode {
            background: rgba(20, 20, 30, 0.95);
        }

        .center-dial.dice-mode .direction,
        .center-dial.dice-mode .dial-round {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .dice-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(5px);
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        .dice-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }

        .dice-container {
            display: flex;
            gap: 12px;
            opacity: 0;
            pointer-events: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: opacity 0.5s 0.2s; /* å»¶è¿Ÿæ˜¾ç¤ºï¼Œç­‰åœ†ç›˜å˜å¤§ */
        }
        .center-dial.dice-mode .dice-container {
            opacity: 1;
            pointer-events: auto;
        }

        .dice-box {
            width: 30px;
            height: 30px;
            position: relative;
            transform-style: preserve-3d;
            /* è¿‡æ¸¡æ—¶é—´ç”±JSåŠ¨æ€æ§åˆ¶ */
        }

        .dice-face {
            position: absolute;
            width: 100%;
            height: 100%;
            background: #f9fafb;
            border-radius: 4px;
            border: 1px solid #d1d5db;
            box-shadow: inset 0 0 4px rgba(0,0,0,0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            backface-visibility: hidden;
        }
        
        .dice-face-inner {
            width: 100%;
            height: 100%;
            padding: 3px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
        }
        .dot {
            background-color: #333;
            border-radius: 50%;
            width: 6px;
            height: 6px;
            align-self: center;
            justify-self: center;
        }
        .dot.red { background-color: #ef4444; } 
        
        /* é¢ä½ç½®å®šä¹‰ (å°ºå¯¸30px, åç§»15px) */
        .face-1 { transform: rotateY(0deg) translateZ(15px); }
        .face-6 { transform: rotateY(180deg) translateZ(15px); }
        .face-3 { transform: rotateY(90deg) translateZ(15px); }
        .face-4 { transform: rotateY(-90deg) translateZ(15px); }
        .face-5 { transform: rotateX(90deg) translateZ(15px); }
        .face-2 { transform: rotateX(-90deg) translateZ(15px); }

        /* åŠ¨ç”» */
        .fade-enter-active, .fade-leave-active { transition: opacity 0.3s; }
        .fade-enter-from, .fade-leave-to { opacity: 0; }
        
        .slide-up-enter-active, .slide-up-leave-active { transition: all 0.3s; }
        .slide-up-enter-from, .slide-up-leave-to { transform: translateY(100%); opacity: 0; }

        /* ç»“ç®—é€‰æ‹©å™¨ */
        .settle-grid {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 10px;
            align-items: center;
            margin-bottom: 20px;
        }
        .player-select-box {
            padding: 10px;
            border-radius: 12px;
            background: #f3f4f6;
            text-align: center;
            cursor: pointer;
            border: 2px solid transparent;
        }
        body.dark .player-select-box { background: #374151; }
        .player-select-box.selected { border-color: var(--primary); background: rgba(99, 102, 241, 0.1); }
        .arrow-icon { color: var(--text-light); opacity: 0.5; }
        body.dark .arrow-icon { color: var(--text-dark); }

        /* å†å²è®°å½• */
        .history-item {
            border-left: 3px solid var(--primary);
            padding-left: 12px;
            margin-bottom: 16px;
        }
        .history-meta { font-size: 12px; opacity: 0.6; margin-bottom: 4px; display: flex; justify-content: space-between; }
        .history-trans { font-size: 14px; margin-bottom: 2px; }
        .trans-amount { font-weight: bold; color: var(--primary); }

        /* ç»Ÿè®¡å›¾è¡¨å®¹å™¨ */
        .chart-container { position: relative; height: 300px; width: 100%; }
        
        /* å¸®åŠ©è¯´æ˜åŒºåŸŸ */
        .help-section {
            background: #f9fafb;
            padding: 16px;
            border-radius: 12px;
            margin-bottom: 16px;
            border: 1px solid #e5e7eb;
        }
        body.dark .help-section {
            background: #374151;
            border-color: #4b5563;
        }
        
        /* å¿«é€Ÿç»“ç®—èƒŒæ™¯é®ç½© */
        .quick-settle-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            z-index: 199;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        .quick-settle-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }
        
        /* å¿«é€Ÿç»“ç®—è¾“å…¥æ¡† */
        .quick-settle-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: white;
            border-radius: 24px;
            padding: 32px 24px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3);
            z-index: 200;
            min-width: 300px;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        body.dark .quick-settle-modal { background: #1f2937; border: 1px solid rgba(255,255,255,0.1); }
        .quick-settle-modal.show {
            opacity: 1;
            pointer-events: auto;
            transform: translate(-50%, -50%) scale(1);
        }
        
        .quick-settle-title {
            font-size: 18px;
            font-weight: 600;
            text-align: center;
            margin-bottom: 20px;
            line-height: 1.4;
        }
        
        .quick-settle-amount {
            width: 100%;
            padding: 16px;
            border-radius: 16px;
            border: 3px solid var(--primary);
            background: #f9fafb;
            font-size: 32px;
            font-weight: 800;
            text-align: center;
            margin-bottom: 20px;
            color: var(--primary);
        }
        body.dark .quick-settle-amount { background: #374151; color: var(--primary); }
        .quick-settle-amount:focus { outline: none; box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.2); }
        
        .quick-settle-actions {
            display: flex;
            gap: 10px;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- é¡¶éƒ¨æ  -->
        <header class="header">
            <div class="round-badge" @click="showRoundModal">
                ç¬¬ {{ currentRound }} å±€
            </div>
            <div class="header-actions">
                <button class="icon-btn" @click="toggleTheme">
                    <i class="fas" :class="isDark ? 'fa-sun' : 'fa-moon'"></i>
                </button>
                <button class="icon-btn" @click="showStats">
                    <i class="fas fa-chart-line"></i>
                </button>
                <button class="icon-btn" @click="showHistory">
                    <i class="fas fa-history"></i>
                </button>
                <button class="icon-btn" @click="showSettings">
                    <i class="fas fa-cog"></i>
                </button>
            </div>
        </header>

        <!-- æ¸¸æˆä¸»åŒºåŸŸ -->
        <main class="game-area">
            <!-- éª°å­æ¨¡å¼é®ç½© -->
            <div class="dice-overlay" :class="{ show: diceMode }" @click="closeDiceMode"></div>

            <!-- ä¸­é—´è½¬ç›˜ -->
            <div class="center-dial" 
                 :class="{ 
                     'dice-mode': diceMode,
                     'is-rolling': diceMode && isRolling,
                     'roll-finished': diceMode && !isRolling && hasRolled
                 }"
                 :style="{ transform: diceMode ? 'scale(2.5)' : `rotate(${dialRotation}deg)` }"
                 @click="handleDialClick">
                <!-- åªæœ‰å½“è¯¥æ–¹å‘å¯¹åº”çš„æ˜¯ä¸œ(dealerIndex)æ—¶æ‰é«˜äº® -->
                <div class="direction dir-0 is-east">æ±</div>
                <div class="direction dir-1">å—</div>
                <div class="direction dir-2">è¥¿</div>
                <div class="direction dir-3">åŒ—</div>
                
                <!-- æ•°å­—ç›´æ¥æ˜¾ç¤ºï¼Œè·Ÿéšçˆ¶å®¹å™¨æ—‹è½¬ï¼Œæ­£å¯¹åº„å®¶ -->
                <div class="dial-round">{{ currentRound }}</div>

                <!-- éª°å­å®¹å™¨ -->
                <div class="dice-container">
                    <div class="dice-box" :style="diceStyles[0]">
                        <div class="dice-face face-1"><div class="dice-face-inner"><div class="dot red" style="grid-area: 2/2;"></div></div></div>
                        <div class="dice-face face-2"><div class="dice-face-inner"><div class="dot" style="grid-area: 1/3;"></div><div class="dot" style="grid-area: 3/1;"></div></div></div>
                        <div class="dice-face face-3"><div class="dice-face-inner"><div class="dot" style="grid-area: 1/3;"></div><div class="dot" style="grid-area: 2/2;"></div><div class="dot" style="grid-area: 3/1;"></div></div></div>
                        <div class="dice-face face-4"><div class="dice-face-inner"><div class="dot red" style="grid-area: 1/1;"></div><div class="dot red" style="grid-area: 1/3;"></div><div class="dot red" style="grid-area: 3/1;"></div><div class="dot red" style="grid-area: 3/3;"></div></div></div>
                        <div class="dice-face face-5"><div class="dice-face-inner"><div class="dot" style="grid-area: 1/1;"></div><div class="dot" style="grid-area: 1/3;"></div><div class="dot" style="grid-area: 2/2;"></div><div class="dot" style="grid-area: 3/1;"></div><div class="dot" style="grid-area: 3/3;"></div></div></div>
                        <div class="dice-face face-6"><div class="dice-face-inner"><div class="dot" style="grid-area: 1/1;"></div><div class="dot" style="grid-area: 1/3;"></div><div class="dot" style="grid-area: 2/1;"></div><div class="dot" style="grid-area: 2/3;"></div><div class="dot" style="grid-area: 3/1;"></div><div class="dot" style="grid-area: 3/3;"></div></div></div>
                    </div>
                    <div class="dice-box" :style="diceStyles[1]">
                        <div class="dice-face face-1"><div class="dice-face-inner"><div class="dot red" style="grid-area: 2/2;"></div></div></div>
                        <div class="dice-face face-2"><div class="dice-face-inner"><div class="dot" style="grid-area: 1/3;"></div><div class="dot" style="grid-area: 3/1;"></div></div></div>
                        <div class="dice-face face-3"><div class="dice-face-inner"><div class="dot" style="grid-area: 1/3;"></div><div class="dot" style="grid-area: 2/2;"></div><div class="dot" style="grid-area: 3/1;"></div></div></div>
                        <div class="dice-face face-4"><div class="dice-face-inner"><div class="dot red" style="grid-area: 1/1;"></div><div class="dot red" style="grid-area: 1/3;"></div><div class="dot red" style="grid-area: 3/1;"></div><div class="dot red" style="grid-area: 3/3;"></div></div></div>
                        <div class="dice-face face-5"><div class="dice-face-inner"><div class="dot" style="grid-area: 1/1;"></div><div class="dot" style="grid-area: 1/3;"></div><div class="dot" style="grid-area: 2/2;"></div><div class="dot" style="grid-area: 3/1;"></div><div class="dot" style="grid-area: 3/3;"></div></div></div>
                        <div class="dice-face face-6"><div class="dice-face-inner"><div class="dot" style="grid-area: 1/1;"></div><div class="dot" style="grid-area: 1/3;"></div><div class="dot" style="grid-area: 2/1;"></div><div class="dot" style="grid-area: 2/3;"></div><div class="dot" style="grid-area: 3/1;"></div><div class="dot" style="grid-area: 3/3;"></div></div></div>
                    </div>
                </div>
            </div>

            <!-- ç©å®¶å¡ç‰‡ -->
            <div v-for="(seat, index) in seats" :key="index" 
                 class="player-card" 
                 :class="[
                     `pos-${index}`, 
                     { dealer: dealerIndex === index },
                     { dragging: dragState.dragging && dragState.fromIndex === index && !dragState.draggingNextRound },
                     { 'drag-over': dragState.overIndex === index && (dragState.fromIndex !== index || dragState.draggingNextRound) && (seat || dragState.draggingNextRound) },
                     { 'empty-seat': !seat }
                 ]"
                 :draggable="seat ? true : false"
                 @click="handleSeatClick(index)"
                 @dragstart="handleDragStart(index, $event)"
                 @dragend="handleDragEnd"
                 @dragover="handleDragOver(index, $event)"
                 @dragleave="handleDragLeave"
                 @drop="handleDrop(index, $event)"
                 @touchstart="handleTouchStart(index, $event)"
                 @touchmove="handleTouchMove($event)"
                 @touchend="handleTouchEnd($event)">
                <!-- åº„å®¶æ ‡è®° -->
                <div v-if="dealerIndex === index && seat" class="dealer-badge">
                    <i v-if="dealerStreak === 0" class="fas fa-crown"></i>
                    <span v-else>{{ dealerStreak }}</span>
                </div>
                
                <div v-if="seat" style="width: 100%; text-align: center;">
                    <div class="player-name">{{ seat }}</div>
                    <div class="player-score">
                        <count-up :to="getPlayerScore(seat)"></count-up>
                    </div>
                    <div class="score-diff">
                        <span v-if="lastDiff[seat]" :class="lastDiff[seat] > 0 ? 'diff-pos' : 'diff-neg'">
                            {{ lastDiff[seat] > 0 ? '+' : '' }}{{ lastDiff[seat] }}
                        </span>
                    </div>
                </div>
                <div v-else style="opacity: 0.5; font-style: italic;">
                    <i class="fas fa-plus-circle" style="margin-bottom: 8px; font-size: 24px;"></i>
                    <div>å…¥åº§</div>
                </div>
            </div>
        </main>

        <!-- åº•éƒ¨æ“ä½œæ  -->
        <footer class="action-bar">
            <button class="btn btn-warning" @click="undo" :disabled="history.length === 0" :style="{ opacity: history.length ? 1 : 0.5 }">
                <i class="fas fa-undo"></i> æ’¤é”€
            </button>
            <button 
                class="btn btn-secondary next-round-btn" 
                :class="{ dragging: dragState.draggingNextRound }"
                draggable="true"
                @click="handleNextRoundClick"
                @dragstart="handleNextRoundDragStart"
                @dragend="handleNextRoundDragEnd"
                @touchstart="handleNextRoundTouchStart"
                @touchmove="handleNextRoundTouchMove"
                @touchend="handleNextRoundTouchEnd"
                style="flex: 1; justify-content: center;">
                ä¸‹ä¸€å±€ <i class="fas fa-chevron-right"></i>
            </button>
        </footer>

        <!-- æ¨¡æ€æ¡†ç»„ä»¶ -->
        
        <!-- 1. ç»“ç®—æ¨¡æ€æ¡† -->
        <div class="modal-overlay" :class="{ show: modals.settle }" @click="closeModal('settle')">
            <div class="modal-card" @click.stop>
                <div class="modal-title">ç»“ç®—åˆ†æ•°</div>
                
                <div class="settle-grid">
                    <div class="player-select-box" :class="{ selected: settleFrom }" @click="selectingFrom = true">
                        {{ settleFrom || 'è°ç»™é’±?' }}
                    </div>
                    <i class="fas fa-arrow-right arrow-icon"></i>
                    <div class="player-select-box" :class="{ selected: settleTo }" @click="selectingFrom = false">
                        {{ settleTo || 'ç»™è°?' }}
                    </div>
                </div>

                <!-- ç©å®¶é€‰æ‹©åˆ—è¡¨ -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 20px;">
                    <div v-for="p in activePlayers" :key="p" 
                         class="list-item" 
                         :class="{ active: (selectingFrom ? settleFrom : settleTo) === p }"
                         style="justify-content: center; margin: 0;"
                         @click="selectSettlePlayer(p)">
                        {{ p }}
                    </div>
                </div>

                <div class="input-group">
                    <input type="number" v-model.number="settleAmount" class="input-field" placeholder="è¾“å…¥é‡‘é¢" ref="amountInput">
                </div>

                <div style="display: flex; gap: 10px;">
                    <button class="btn btn-secondary" style="flex: 1;" @click="closeModal('settle')">å–æ¶ˆ</button>
                    <button class="btn btn-primary" style="flex: 1;" @click="confirmSettle">ç¡®è®¤</button>
                </div>
            </div>
        </div>

        <!-- 2. é€‰äººå…¥åº§æ¨¡æ€æ¡† -->
        <div class="modal-overlay" :class="{ show: modals.seat }" @click="closeModal('seat')">
            <div class="modal-card" @click.stop>
                <div class="modal-title">é€‰æ‹©ç©å®¶å…¥åº§</div>
                <div class="input-field" style="display: flex; gap: 8px; padding: 4px; border: none; background: transparent;">
                    <input v-model="newPlayerName" class="input-field" placeholder="æ–°ç©å®¶åå­—" style="margin: 0;">
                    <button class="btn btn-primary" @click="addNewPlayer" style="padding: 0 16px;">
                        <i class="fas fa-plus"></i>
                    </button>
                </div>
                <div style="max-height: 300px; overflow-y: auto;">
                    <div v-for="p in availablePlayers" :key="p.name" class="list-item" @click="sitDown(p.name)">
                        <span>{{ p.name }}</span>
                        <span style="font-weight: bold;">{{ p.score }}</span>
                    </div>
                </div>
                <button class="btn btn-secondary" style="width: 100%; margin-top: 16px;" @click="closeModal('seat')">å–æ¶ˆ</button>
            </div>
        </div>

        <!-- 3. å†å²è®°å½•æ¨¡æ€æ¡† -->
        <div class="modal-overlay" :class="{ show: modals.history }" @click="closeModal('history')">
            <div class="modal-card" @click.stop>
                <div class="modal-title">å†å²è®°å½•</div>
                <div v-if="history.length === 0" style="text-align: center; opacity: 0.5; padding: 20px;">æš‚æ— è®°å½•</div>
                <div v-else style="max-height: 400px; overflow-y: auto;">
                    <div v-for="(h, i) in history" :key="i" class="history-item">
                        <div class="history-meta">
                            <span>ç¬¬ {{ h.round }} å±€</span>
                            <span>{{ formatTime(h.time) }}</span>
                        </div>
                        <div v-for="(t, ti) in h.transactions" :key="ti" class="history-trans">
                            {{ t.from }} <i class="fas fa-arrow-right" style="font-size: 10px; opacity: 0.5;"></i> {{ t.to }} : 
                            <span class="trans-amount">{{ t.amount }}</span>
                        </div>
                    </div>
                </div>
                <button class="btn btn-primary" style="width: 100%; margin-top: 16px;" @click="closeModal('history')">
                    <i class="fas fa-check"></i> å…³é—­
                </button>
            </div>
        </div>

        <!-- 4. ç»Ÿè®¡å›¾è¡¨æ¨¡æ€æ¡† -->
        <div class="modal-overlay" :class="{ show: modals.stats }" @click="closeModal('stats')">
            <div class="modal-card" style="max-width: 600px; width: 95%;" @click.stop>
                <div class="modal-title">åˆ†æ•°èµ°åŠ¿</div>
                <div class="chart-container">
                    <canvas id="scoreChart"></canvas>
                </div>
                <button class="btn btn-primary" style="width: 100%; margin-top: 16px;" @click="closeModal('stats')">
                    <i class="fas fa-check"></i> å…³é—­
                </button>
            </div>
        </div>

        <!-- 5. è®¾ç½®æ¨¡æ€æ¡† -->
        <div class="modal-overlay" :class="{ show: modals.settings }" @click="closeModal('settings')">
            <div class="modal-card" @click.stop>
                <div class="modal-title">è®¾ç½®</div>
                
                <!-- æ“ä½œè¯´æ˜ -->
                <div class="help-section">
                    <div style="font-weight: 600; margin-bottom: 12px; display: flex; align-items: center; gap: 8px;">
                        <i class="fas fa-info-circle" style="color: var(--primary);"></i>
                        <span>æ“ä½œè¯´æ˜</span>
                    </div>
                    <div style="font-size: 14px; line-height: 1.6; opacity: 0.8;">
                        <div style="margin-bottom: 8px;">
                            <strong>ğŸ’° ç»“ç®—åˆ†æ•°ï¼š</strong>æ‹–åŠ¨ç©å®¶Aåˆ°ç©å®¶Bï¼Œè¾“å…¥é‡‘é¢åç¡®è®¤ï¼ˆAç»™Båˆ†æ•°ï¼‰
                        </div>
                        <div style="margin-bottom: 8px;">
                            <strong>ğŸ‘‘ æŒ‡å®šåˆå§‹åº„å®¶ï¼š</strong>åœ¨æœªåæ»¡å‰ï¼Œæ‹–åŠ¨"ä¸‹ä¸€å±€"åˆ°ä»»æ„ä½ç½®æŒ‡å®šåˆå§‹åº„å®¶ï¼ˆä¸å¢åŠ å±€æ•°ï¼‰
                        </div>
                        <div style="margin-bottom: 8px;">
                            <strong>ğŸ² æŒ‡å®šåº„å®¶ï¼š</strong>æ¸¸æˆä¸­ï¼Œæ‹–åŠ¨"ä¸‹ä¸€å±€"åˆ°ç©å®¶èº«ä¸Šè¿›è¡Œæ¢åº„æˆ–è¿åº„
                        </div>
                        <div style="margin-bottom: 8px;">
                            <strong>ğŸ”„ è‡ªåŠ¨æ¢åº„ï¼š</strong>ç‚¹å‡»"ä¸‹ä¸€å±€"æŒ‰é’®ï¼Œè‡ªåŠ¨æ¢åº„åˆ°ä¸‹ä¸€å®¶å¹¶è¿›å…¥ä¸‹ä¸€å±€
                        </div>
                        <div style="margin-bottom: 8px;">
                            <strong>ğŸ² æ‰“éª°å­ï¼š</strong>ç‚¹å‡»ä¸­é—´åœ†ç›˜è¿›å…¥éª°å­æ¨¡å¼ï¼Œå†æ¬¡ç‚¹å‡»è¿›è¡Œæ·éª°å­
                        </div>
                        <div>
                            <strong>â†©ï¸ æ’¤é”€æ“ä½œï¼š</strong>ç‚¹å‡»"æ’¤é”€"æŒ‰é’®å¯æ’¤é”€ä¸Šä¸€æ¬¡ç»“ç®—
                        </div>
                    </div>
                </div>
                
                <div class="list-item" @click="clearData" style="color: var(--danger); cursor: pointer;">
                    <span><i class="fas fa-trash-alt" style="margin-right: 8px;"></i> æ¸…ç©ºæ‰€æœ‰æ•°æ®</span>
                </div>
                <button class="btn btn-primary" style="width: 100%; margin-top: 16px;" @click="closeModal('settings')">
                    <i class="fas fa-check"></i> å…³é—­
                </button>
            </div>
        </div>

        <!-- 6. æ‰‹åŠ¨è°ƒåº„æ¨¡æ€æ¡† -->
        <div class="modal-overlay" :class="{ show: modals.dealerSet }" @click="closeModal('dealerSet')">
            <div class="modal-card" @click.stop>
                <div class="modal-title">æŒ‡å®šåº„å®¶</div>
                <!-- Vue 3 fix: v-if has higher priority than v-for, so we cannot use seat in v-if on the same element -->
                <template v-for="(s, i) in seats" :key="i">
                    <div v-if="s"
                         class="list-item" 
                         :class="{ active: dealerIndex === i }"
                         @click="setDealer(i)">
                        <span>{{ s }}</span>
                        <span v-if="dealerIndex === i"><i class="fas fa-check"></i></span>
                    </div>
                </template>
                <button class="btn btn-secondary" style="width: 100%; margin-top: 16px;" @click="closeModal('dealerSet')">å–æ¶ˆ</button>
            </div>
        </div>

        <!-- 7. å¿«é€Ÿç»“ç®—æ¨¡æ€æ¡† -->
        <div class="quick-settle-overlay" :class="{ show: quickSettle.show }" @click="cancelQuickSettle"></div>
        <div class="quick-settle-modal" :class="{ show: quickSettle.show }">
            <div class="quick-settle-title">
                {{ quickSettle.from }} <i class="fas fa-arrow-right" style="color: var(--primary); margin: 0 8px;"></i> {{ quickSettle.to }}
            </div>
            <input 
                type="number" 
                inputmode="numeric"
                v-model="quickSettle.amount" 
                class="quick-settle-amount" 
                placeholder="0"
                ref="quickAmountInput"
                @keyup.enter="confirmQuickSettle"
                @keyup.esc="cancelQuickSettle">
            <div class="quick-settle-actions">
                <button class="btn btn-secondary" style="flex: 1;" @click="cancelQuickSettle">å–æ¶ˆ</button>
                <button class="btn btn-primary" style="flex: 1;" @click="confirmQuickSettle">ç¡®è®¤</button>
            </div>
        </div>

    </div>

    <script>
        const { createApp, ref, computed, onMounted, watch, nextTick } = Vue;

        // æ•°å­—æ»šåŠ¨ç»„ä»¶
        const CountUp = {
            props: ['to'],
            template: '<span>{{ displayValue }}</span>',
            setup(props) {
                const displayValue = ref(props.to);
                let animationFrame;

                watch(() => props.to, (newVal, oldVal) => {
                    const start = oldVal || 0;
                    const end = newVal;
                    const duration = 1000;
                    let startTime = null;

                    const animate = (timestamp) => {
                        if (!startTime) startTime = timestamp;
                        const progress = Math.min((timestamp - startTime) / duration, 1);
                        const ease = 1 - Math.pow(1 - progress, 4); // easeOutQuart
                        displayValue.value = Math.floor(progress * (end - start) + start);

                        if (progress < 1) {
                            animationFrame = requestAnimationFrame(animate);
                        } else {
                            displayValue.value = end;
                        }
                    };
                    cancelAnimationFrame(animationFrame);
                    animationFrame = requestAnimationFrame(animate);
                });

                return { displayValue };
            }
        };

        createApp({
            components: { CountUp },
            setup() {
                // --- State ---
                const isDark = ref(false);
                const players = ref([]); // { name, score }
                const seats = ref([null, null, null, null]); // names
                const currentRound = ref(1);
                const dealerIndex = ref(0);
                const dealerStreak = ref(0); // å½“å‰åº„å®¶çš„è¿åº„æ¬¡æ•°
                const history = ref([]);
                const lastDiff = ref({}); // { name: diff } for animation
                
                // UI State
                const modals = ref({
                    settle: false,
                    seat: false,
                    nextRound: false,
                    history: false,
                    stats: false,
                    settings: false,
                    dealerSet: false
                });
                
                const activeSeatIndex = ref(null);
                const newPlayerName = ref('');
                
                // Settle State
                const settleFrom = ref(null);
                const settleTo = ref(null);
                const settleAmount = ref('');
                const selectingFrom = ref(true);
                const amountInput = ref(null);

                // Drag State (for both desktop and mobile)
                const dragState = ref({
                    dragging: false,
                    fromIndex: null,
                    overIndex: null,
                    touchStartX: 0,
                    touchStartY: 0,
                    draggingNextRound: false // Flag for dragging next round button
                });
                let touchTimeout = null;
                let dragClone = null;
                let lastAngle = null; // Track last angle to prevent jumps
                let nextRoundTouchTimeout = null;

                // Quick Settle State
                const quickSettle = ref({
                    show: false,
                    from: null,
                    to: null,
                    amount: ''
                });
                const quickAmountInput = ref(null);

                // Chart
                let chartInstance = null;

                // Dice State
                const diceMode = ref(false);
                const isRolling = ref(false);
                const isAnimating = ref(false);
                const hasRolled = ref(false);
                // ä¸¤ä¸ªéª°å­çš„å½“å‰æ—‹è½¬è§’åº¦
                const diceRotation = ref([{ x: 0, y: 0 }, { x: 0, y: 0 }]);

                const diceStyles = computed(() => {
                    return diceRotation.value.map((rot) => {
                        // å¦‚æœæ­£åœ¨åŠ¨ç”»ä¸­ï¼Œä½¿ç”¨åŠ¨æ€ç”Ÿæˆçš„éšæœºæ—¶é—´ï¼›å¦åˆ™ä½¿ç”¨å¤ä½æ—¶é—´
                        // isAnimating ä¿æŒæ•´ä¸ªåŠ¨ç”»å‘¨æœŸçš„ trueï¼Œç¡®ä¿ easing æ›²çº¿ä¸ä¸­æ–­
                        const transitionTime = isAnimating.value ? `${rot.duration}ms` : '0.5s';
                        return {
                            transform: `rotateX(${rot.x}deg) rotateY(${rot.y}deg)`,
                            transition: `transform ${transitionTime} cubic-bezier(0.1, 0.9, 0.2, 1)`
                        };
                    });
                });

                const handleDialClick = () => {
                    if (!diceMode.value) {
                        // è¿›å…¥éª°å­æ¨¡å¼
                        diceMode.value = true;
                        hasRolled.value = false;
                        resetDice(); 
                    } else {
                        // å·²ç»åœ¨éª°å­æ¨¡å¼
                        if (isRolling.value) return; // æ­£åœ¨æ»šåŠ¨äº¤äº’é”å®šä¸­ï¼Œå¿½ç•¥
                        // å¼€å§‹æ·éª°å­
                        rollDice();
                    }
                };

                const closeDiceMode = () => {
                    if (isRolling.value) return; // æ­£åœ¨æ»šåŠ¨äº¤äº’é”å®šä¸­ï¼Œä¸å¯é€€å‡º
                    // åªè¦ä¸åœ¨æ»šåŠ¨ä¸­ï¼Œç‚¹å‡»å¤–éƒ¨éƒ½å¯ä»¥é€€å‡ºï¼ˆåŒ…æ‹¬æ²¡æ‰“éª°å­å‰ï¼Œå’Œæ‰“å®Œéª°å­åï¼‰
                    diceMode.value = false;
                };

                const resetDice = () => {
                    // éšæœºç”Ÿæˆåˆå§‹ç‚¹æ•°
                    const v1 = Math.floor(Math.random() * 6) + 1;
                    const v2 = Math.floor(Math.random() * 6) + 1;
                    
                    const getBaseAngle = (val) => {
                        switch(val) {
                            case 1: return { x: 0, y: 0 };
                            case 2: return { x: 90, y: 0 };
                            case 3: return { x: 0, y: -90 };
                            case 4: return { x: 0, y: 90 };
                            case 5: return { x: -90, y: 0 };
                            case 6: return { x: 0, y: 180 };
                            default: return { x: 0, y: 0 };
                        }
                    };

                    const base1 = getBaseAngle(v1);
                    const base2 = getBaseAngle(v2);

                     diceRotation.value = [
                         { x: base1.x + Math.random() * 20 - 10, y: base1.y + Math.random() * 20 - 10 },
                         { x: base2.x + Math.random() * 20 - 10, y: base2.y + Math.random() * 20 - 10 }
                     ];
                };

                const rollDice = () => {
                    isRolling.value = true;     // é”å®šäº¤äº’ï¼Œæ˜¾ç¤ºçº¢å…‰
                    isAnimating.value = true;   // å¼€å§‹åŠ¨ç”» CSS
                    hasRolled.value = true;
                    
                    const v1 = Math.floor(Math.random() * 6) + 1;
                    const v2 = Math.floor(Math.random() * 6) + 1;
                    
                    // åŸºç¡€åœˆæ•°è°ƒæ•´
                    const minSpins = 4; 
                    
                    // ç”Ÿæˆ1000msåˆ°2500msä¹‹é—´çš„éšæœºæ—¶é—´
                    const duration1 = Math.floor(Math.random() * 1500) + 1000;
                    const duration2 = Math.floor(Math.random() * 1500) + 1000;
                    
                    // å–æœ€å¤§çš„æ—¶é—´ä½œä¸ºç»“æŸæ—¶é—´
                    const maxDuration = Math.max(duration1, duration2);

                    diceRotation.value = [
                        { ...calculateDiceRotation(0, v1, minSpins), duration: duration1 },
                        { ...calculateDiceRotation(1, v2, minSpins), duration: duration2 }
                    ];
                    
                    // æå‰ 500ms è§£é”äº¤äº’å¹¶æ˜¾ç¤ºç»¿å…‰ï¼ˆè®©ç”¨æˆ·æ„Ÿè§‰å·²ç»åœäº†ï¼‰
                    setTimeout(() => {
                        isRolling.value = false;
                    }, Math.max(0, maxDuration - 500));

                    // åŠ¨ç”»å®é™…ç»“æŸåï¼Œé‡ç½®åŠ¨ç”»çŠ¶æ€ï¼ˆæ¢å¤ CSS transition åˆ°çŸ­æ—¶é—´å¤ä½æ¨¡å¼ï¼‰
                    setTimeout(() => {
                        isAnimating.value = false;
                    }, maxDuration);
                };
                
                const calculateDiceRotation = (index, value, minSpins) => {
                    // è·å–å½“å‰è§’åº¦
                    const current = diceRotation.value[index];
                    
                    // ç›®æ ‡åŸºç¡€è§’åº¦
                    let baseX = 0, baseY = 0;
                    switch(value) {
                        case 1: baseX = 0; baseY = 0; break;
                        case 2: baseX = 90; baseY = 0; break;
                        case 3: baseX = 0; baseY = -90; break;
                        case 4: baseX = 0; baseY = 90; break;
                        case 5: baseX = -90; baseY = 0; break;
                        case 6: baseX = 0; baseY = 180; break;
                    }
                    
                    // è®¡ç®—ä¸‹ä¸€ä¸ªè§’åº¦ï¼Œç¡®ä¿æ˜¯åœ¨å½“å‰åŸºç¡€ä¸Šç´¯åŠ ï¼Œä¸”è‡³å°‘è½¬ minSpins åœˆ
                    // 1. è®¡ç®—å½“å‰è§’åº¦ç›¸å¯¹äº360çš„ä½™æ•°ï¼Œä»¥ä¾¿æ‰¾åˆ°å»å¾€ baseX çš„æœ€çŸ­æ­£å‘è·¯å¾„
                    // å®é™…ä¸Šï¼Œæˆ‘ä»¬åªéœ€è¦ç¡®ä¿ delta æ˜¯æ­£çš„å³å¯
                    
                    const calcNextAngle = (currAngle, baseAngle) => {
                        // å½“å‰è§’åº¦
                        const curr = currAngle;
                        // ç›®æ ‡ä½™æ•°
                        const targetMod = baseAngle; 
                        // å½“å‰ä½™æ•°
                        const currMod = curr % 360;
                        
                        // è®¡ç®—å·®å€¼ï¼šæˆ‘ä»¬éœ€è¦åŠ å¤šå°‘æ‰èƒ½åˆ°è¾¾ä¸‹ä¸€ä¸ª targetMod
                        let delta = targetMod - currMod;
                        
                        // ç¡®ä¿ delta > 0ï¼Œä¿è¯æ­£å‘æ—‹è½¬
                        while (delta <= 0) delta += 360;
                        
                        // åŠ ä¸ŠåŸºç¡€å·®å€¼åï¼Œå†é¢å¤–åŠ éšæœºåœˆæ•°
                        const extraSpins = Math.floor(Math.random() * 3) + minSpins;
                        
                        return curr + delta + (extraSpins * 360);
                    };
                    
                    return { 
                        x: calcNextAngle(current.x, baseX),
                        y: calcNextAngle(current.y, baseY)
                    };
                };

                // --- Computed ---
                const activePlayers = computed(() => seats.value.filter(n => n));
                const availablePlayers = computed(() => players.value.filter(p => !seats.value.includes(p.name)));
                
                // Track rotation for smooth counter-clockwise animation
                // ç›®æ ‡è§’åº¦æ˜ å°„ï¼šåº§ä½0=0Â°, åº§ä½1=-90Â°, åº§ä½2=-180Â°, åº§ä½3=-270Â°
                // ä½¿ç”¨å‡½æ•°æ¥å»¶è¿Ÿåˆå§‹åŒ–ï¼Œç¡®ä¿èƒ½è·å–åˆ°æ­£ç¡®çš„åˆå§‹dealerIndex
                let currentRotation = null;
                let previousDealerIndex = null;
                
                const dialRotation = computed(() => {
                    const targetIndex = dealerIndex.value;
                    
                    // é¦–æ¬¡åˆå§‹åŒ–ï¼šç›´æ¥è®¾ç½®åˆ°æ­£ç¡®ä½ç½®ï¼Œä¸éœ€è¦åŠ¨ç”»
                    if (currentRotation === null) {
                        currentRotation = -targetIndex * 90;
                        previousDealerIndex = targetIndex;
                        return currentRotation;
                    }
                    
                    // è®¡ç®—ç›®æ ‡è§’åº¦ï¼ˆä¸œå­—åº”è¯¥æŒ‡å‘çš„æ–¹å‘ï¼‰
                    // åº§ä½0(åº•éƒ¨)=0Â°, åº§ä½1(å³ä¾§)=-90Â°, åº§ä½2(é¡¶éƒ¨)=-180Â°, åº§ä½3(å·¦ä¾§)=-270Â°
                    const targetAngle = -targetIndex * 90;
                    
                    // å¦‚æœåº„å®¶å˜äº†ï¼Œè®¡ç®—é€†æ—¶é’ˆè·¯å¾„
                    if (targetIndex !== previousDealerIndex) {
                        // è®¡ç®—ä»å½“å‰è§’åº¦åˆ°ç›®æ ‡è§’åº¦çš„æœ€çŸ­é€†æ—¶é’ˆè·¯å¾„
                        let diff = targetAngle - currentRotation;
                        
                        // æ ‡å‡†åŒ–å·®å€¼åˆ° (-360, 0] åŒºé—´ï¼ˆé€†æ—¶é’ˆæ–¹å‘ï¼‰
                        while (diff > 0) diff -= 360;
                        while (diff <= -360) diff += 360;
                        
                        // åº”ç”¨é€†æ—¶é’ˆæ—‹è½¬
                        currentRotation += diff;
                        previousDealerIndex = targetIndex;
                    }
                    
                    return currentRotation;
                });
                
                // --- Methods ---
                
                // Init
                onMounted(() => {
                    loadState();
                    initTheme();
                    requestWakeLock();
                });

                // Theme
                const toggleTheme = () => {
                    isDark.value = !isDark.value;
                    localStorage.setItem('mj_theme', isDark.value ? 'dark' : 'light');
                    if (isDark.value) document.body.classList.add('dark');
                    else document.body.classList.remove('dark');
                };

                const initTheme = () => {
                    const saved = localStorage.getItem('mj_theme');
                    if (saved) {
                        isDark.value = saved === 'dark';
                    } else {
                        isDark.value = window.matchMedia('(prefers-color-scheme: dark)').matches;
                    }
                    if (isDark.value) document.body.classList.add('dark');
                };

                // Data Persistence
                const saveState = () => {
                    const state = {
                        players: players.value,
                        seats: seats.value,
                        currentRound: currentRound.value,
                        dealerIndex: dealerIndex.value,
                        dealerStreak: dealerStreak.value,
                        history: history.value
                    };
                    localStorage.setItem('mj_data_v3', JSON.stringify(state));
                };

                const loadState = () => {
                    const saved = localStorage.getItem('mj_data_v3');
                    if (saved) {
                        const data = JSON.parse(saved);
                        players.value = data.players || [];
                        seats.value = data.seats || [null, null, null, null];
                        currentRound.value = data.currentRound || 1;
                        dealerIndex.value = data.dealerIndex || 0;
                        dealerStreak.value = data.dealerStreak || 0;
                        history.value = data.history || [];
                    }
                };

                // Player Management
                const getPlayerScore = (name) => {
                    const p = players.value.find(p => p.name === name);
                    return p ? p.score : 0;
                };

                const handleSeatClick = (index) => {
                    // Don't open seat modal if we just finished dragging
                    if (dragState.value.dragging) return;
                    
                    activeSeatIndex.value = index;
                    modals.value.seat = true;
                };

                const addNewPlayer = () => {
                    const name = newPlayerName.value.trim();
                    if (!name) return;
                    if (players.value.some(p => p.name === name)) return alert('ç©å®¶å·²å­˜åœ¨');
                    players.value.push({ name, score: 0 });
                    newPlayerName.value = '';
                    saveState();
                };

                const sitDown = (name) => {
                    seats.value[activeSeatIndex.value] = name;
                    closeModal('seat');
                    saveState();
                };

                // Settlement
                const openSettleModal = () => {
                    if (activePlayers.value.length < 2) return alert('è¯·å…ˆè®¾ç½®è‡³å°‘2åç©å®¶');
                    settleFrom.value = null;
                    settleTo.value = null;
                    settleAmount.value = '';
                    selectingFrom.value = true;
                    modals.value.settle = true;
                };

                const selectSettlePlayer = (name) => {
                    if (selectingFrom.value) {
                        if (settleTo.value === name) settleTo.value = null; // Swap prevention
                        settleFrom.value = name;
                        selectingFrom.value = false; // Auto advance
                    } else {
                        if (settleFrom.value === name) settleFrom.value = null;
                        settleTo.value = name;
                        // Focus input
                        nextTick(() => amountInput.value?.focus());
                    }
                };

                const confirmSettle = () => {
                    if (!settleFrom.value || !settleTo.value || !settleAmount.value) return;
                    const amount = parseInt(settleAmount.value);
                    if (amount <= 0) return;

                    // Update Scores
                    const fromP = players.value.find(p => p.name === settleFrom.value);
                    const toP = players.value.find(p => p.name === settleTo.value);
                    fromP.score -= amount;
                    toP.score += amount;

                    // Record History
                    history.value.unshift({
                        time: Date.now(),
                        round: currentRound.value,
                        dealerIndex: dealerIndex.value,
                        transactions: [{ from: settleFrom.value, to: settleTo.value, amount }]
                    });

                    // Show Diff Animation
                    lastDiff.value = {};
                    lastDiff.value[settleFrom.value] = -amount;
                    lastDiff.value[settleTo.value] = amount;
                    setTimeout(() => lastDiff.value = {}, 3000);

                    saveState();
                    closeModal('settle');
                };

                const undo = () => {
                    if (history.value.length === 0) return;
                    if (!confirm('ç¡®å®šæ’¤é”€ä¸Šä¸€æ¬¡ç»“ç®—ï¼Ÿ')) return;

                    const last = history.value.shift();
                    last.transactions.forEach(t => {
                        const fromP = players.value.find(p => p.name === t.from);
                        const toP = players.value.find(p => p.name === t.to);
                        if (fromP) fromP.score += t.amount;
                        if (toP) toP.score -= t.amount;
                    });
                    saveState();
                };

                // Next Round Button Drag (Desktop)
                const handleNextRoundDragStart = (event) => {
                    dragState.value.draggingNextRound = true;
                    
                    const img = new Image();
                    img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs=';
                    event.dataTransfer.setDragImage(img, 0, 0);
                    event.dataTransfer.effectAllowed = 'move';
                    event.dataTransfer.setData('text/plain', 'nextRound');
                    
                    dragClone = createNextRoundClone(event.clientX, event.clientY);
                    
                    const onDocumentDrag = (e) => {
                        if (e.clientX !== 0 || e.clientY !== 0) {
                            updateDragClone(e.clientX, e.clientY);
                        }
                    };
                    document.addEventListener('drag', onDocumentDrag);
                    
                    const cleanup = () => {
                        document.removeEventListener('drag', onDocumentDrag);
                        document.removeEventListener('dragend', cleanup);
                    };
                    document.addEventListener('dragend', cleanup);
                };

                const handleNextRoundDragEnd = () => {
                    const targetIndex = dragState.value.overIndex;
                    
                    dragState.value.draggingNextRound = false;
                    dragState.value.overIndex = null;
                    removeDragClone();
                    
                    if (targetIndex !== null) {
                        // åˆ¤æ–­æ˜¯å¦è‡³å°‘æœ‰ä¸€ä¸ªç©å®¶æ²¡æœ‰å…¥åº§
                        const hasEmptySeat = seats.value.some(seat => seat === null);
                        
                        if (hasEmptySeat) {
                            // è‡³å°‘æœ‰ä¸€ä¸ªç©å®¶æ²¡æœ‰å…¥åº§ï¼šåªæŒ‡å®šåº„å®¶ä½ç½®ï¼Œä¸å¢åŠ å±€æ•°
                            dealerIndex.value = targetIndex;
                            dealerStreak.value = 0;
                            saveState();
                        } else {
                            const seat = seats.value[targetIndex];
                            if (seat) {
                                // åˆ¤æ–­æ˜¯å¦æ˜¯åŒä¸€ä¸ªåº„å®¶
                                if (targetIndex === dealerIndex.value) {
                                    // è¿åº„ï¼šå¢åŠ è¿åº„æ¬¡æ•°
                                    dealerStreak.value++;
                                } else {
                                    // æ¢åº„ï¼šé‡ç½®è¿åº„æ¬¡æ•°ï¼Œæ›´æ¢åº„å®¶
                                    dealerIndex.value = targetIndex;
                                    dealerStreak.value = 0;
                                }
                                currentRound.value++;
                                saveState();
                            }
                        }
                    }
                };

                // Next Round Button Touch (Mobile)
                const handleNextRoundTouchStart = (event) => {
                    const touch = event.touches[0];
                    dragState.value.touchStartX = touch.clientX;
                    dragState.value.touchStartY = touch.clientY;
                    
                    if (nextRoundTouchTimeout) clearTimeout(nextRoundTouchTimeout);
                    
                    nextRoundTouchTimeout = setTimeout(() => {
                        dragState.value.draggingNextRound = true;
                        if (!dragClone) {
                            dragClone = createNextRoundClone(dragState.value.touchStartX, dragState.value.touchStartY);
                        }
                    }, 150);
                };

                const handleNextRoundTouchMove = (event) => {
                    const touch = event.touches[0];
                    const dx = Math.abs(touch.clientX - dragState.value.touchStartX);
                    const dy = Math.abs(touch.clientY - dragState.value.touchStartY);
                    
                    if (dx > 10 || dy > 10) {
                        if (nextRoundTouchTimeout) {
                            clearTimeout(nextRoundTouchTimeout);
                            nextRoundTouchTimeout = null;
                        }
                        dragState.value.draggingNextRound = true;
                        
                        if (!dragClone) {
                            dragClone = createNextRoundClone(touch.clientX, touch.clientY);
                        }
                    }
                    
                    if (!dragState.value.draggingNextRound) return;
                    
                    // Don't preventDefault here - it may be too late and cause warnings
                    updateDragClone(touch.clientX, touch.clientY);
                    
                    // Find which card is under touch
                    const element = document.elementFromPoint(touch.clientX, touch.clientY);
                    const card = element?.closest('.player-card');
                    
                    if (card) {
                        const allCards = document.querySelectorAll('.player-card');
                        const cardIndex = Array.from(allCards).indexOf(card);
                        
                        if (cardIndex !== -1) {
                            const seat = seats.value[cardIndex];
                            const hasEmptySeat = seats.value.some(s => s === null);
                            if (hasEmptySeat || seat) {
                                dragState.value.overIndex = cardIndex;
                            } else {
                                dragState.value.overIndex = null;
                            }
                        }
                    } else {
                        dragState.value.overIndex = null;
                    }
                };

                const handleNextRoundTouchEnd = (event) => {
                    if (nextRoundTouchTimeout) {
                        clearTimeout(nextRoundTouchTimeout);
                        nextRoundTouchTimeout = null;
                    }
                    
                    const wasDragging = dragState.value.draggingNextRound;
                    const targetIndex = dragState.value.overIndex;
                    
                    if (wasDragging && targetIndex !== null) {
                        // Don't preventDefault here - it may be too late and cause warnings
                        
                        // åˆ¤æ–­æ˜¯å¦è‡³å°‘æœ‰ä¸€ä¸ªç©å®¶æ²¡æœ‰å…¥åº§
                        const hasEmptySeat = seats.value.some(seat => seat === null);
                        
                        if (hasEmptySeat) {
                            // è‡³å°‘æœ‰ä¸€ä¸ªç©å®¶æ²¡æœ‰å…¥åº§ï¼šåªæŒ‡å®šåº„å®¶ä½ç½®ï¼Œä¸å¢åŠ å±€æ•°
                            dealerIndex.value = targetIndex;
                            dealerStreak.value = 0;
                            saveState();
                        } else {
                            const seat = seats.value[targetIndex];
                            if (seat) {
                                // åˆ¤æ–­æ˜¯å¦æ˜¯åŒä¸€ä¸ªåº„å®¶
                                if (targetIndex === dealerIndex.value) {
                                    // è¿åº„ï¼šå¢åŠ è¿åº„æ¬¡æ•°
                                    dealerStreak.value++;
                                } else {
                                    // æ¢åº„ï¼šé‡ç½®è¿åº„æ¬¡æ•°ï¼Œæ›´æ¢åº„å®¶
                                    dealerIndex.value = targetIndex;
                                    dealerStreak.value = 0;
                                }
                                currentRound.value++;
                                saveState();
                            }
                        }
                    }
                    
                    dragState.value.draggingNextRound = false;
                    dragState.value.overIndex = null;
                    removeDragClone();
                };

                // Drag Clone Helpers
                const normalizeAngle = (angle) => {
                    // Normalize angle to 0-360 range
                    while (angle < 0) angle += 360;
                    while (angle >= 360) angle -= 360;
                    return angle;
                };
                
                const calculateRotationAngle = (x, y) => {
                    // Calculate screen center
                    const centerX = window.innerWidth / 2;
                    const centerY = window.innerHeight / 2;
                    
                    // Calculate angle from center to cursor position
                    // atan2 returns angle in radians, convert to degrees
                    // Add 90 to adjust because our cards point "up" at 0 degrees
                    // Add 180 to make it point outward (away from center)
                    let angle = Math.atan2(y - centerY, x - centerX) * (180 / Math.PI) + 90 + 180;
                    
                    // Smooth angle transition to prevent jumps
                    if (lastAngle !== null) {
                        // Normalize the difference to find shortest path
                        let diff = angle - lastAngle;
                        
                        // Wrap difference to [-180, 180] range
                        while (diff > 180) diff -= 360;
                        while (diff < -180) diff += 360;
                        
                        // Apply the shortest path difference
                        angle = lastAngle + diff;
                    }
                    
                    lastAngle = angle;
                    return angle;
                };
                
                const createDragClone = (seatName, x, y, positionIndex) => {
                    // Reset angle tracking for new drag
                    lastAngle = null;
                    
                    const clone = document.createElement('div');
                    clone.className = 'drag-clone';
                    clone.innerHTML = `
                        <div class="player-name">${seatName}</div>
                        <div class="player-score">${getPlayerScore(seatName)}</div>
                    `;
                    clone.style.left = `${x - 80}px`; // 80 = width/2
                    clone.style.top = `${y - 40}px`; // Approximate center
                    
                    // Calculate rotation based on position relative to screen center
                    const angle = calculateRotationAngle(x, y);
                    clone.style.transform = `rotate(${angle}deg)`;
                    
                    document.body.appendChild(clone);
                    
                    // Trigger fade in
                    requestAnimationFrame(() => {
                        clone.classList.add('show');
                    });
                    
                    return clone;
                };

                const updateDragClone = (x, y) => {
                    if (dragClone) {
                        dragClone.style.left = `${x - 80}px`;
                        dragClone.style.top = `${y - 40}px`;
                        
                        // Update rotation based on new position relative to screen center
                        const angle = calculateRotationAngle(x, y);
                        dragClone.style.transform = `rotate(${angle}deg)`;
                    }
                };

                const removeDragClone = () => {
                    if (dragClone) {
                        dragClone.classList.remove('show');
                        setTimeout(() => {
                            if (dragClone && dragClone.parentNode) {
                                dragClone.parentNode.removeChild(dragClone);
                            }
                            dragClone = null;
                            lastAngle = null; // Reset angle tracking
                        }, 200); // Match transition duration
                    }
                };

                const createNextRoundClone = (x, y) => {
                    lastAngle = null;
                    
                    const clone = document.createElement('div');
                    clone.className = 'drag-clone next-round-clone';
                    clone.innerHTML = `
                        <div class="clone-text">
                            <i class="fas fa-crown" style="font-size: 24px; margin-bottom: 8px;"></i>
                            <div>æŒ‡å®šåº„å®¶</div>
                        </div>
                    `;
                    clone.style.left = `${x - 80}px`;
                    clone.style.top = `${y - 40}px`;
                    
                    const angle = calculateRotationAngle(x, y);
                    clone.style.transform = `rotate(${angle}deg)`;
                    
                    document.body.appendChild(clone);
                    
                    requestAnimationFrame(() => {
                        clone.classList.add('show');
                    });
                    
                    return clone;
                };

                // Drag and Drop (Desktop)
                const handleDragStart = (index, event) => {
                    const seat = seats.value[index];
                    if (!seat) return;
                    
                    dragState.value.dragging = true;
                    dragState.value.fromIndex = index;
                    event.dataTransfer.effectAllowed = 'move';
                    event.dataTransfer.setData('text/plain', index.toString());
                    
                    // Hide default drag image
                    const img = new Image();
                    img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs=';
                    event.dataTransfer.setDragImage(img, 0, 0);
                    
                    // Create clone at cursor position with proper rotation
                    dragClone = createDragClone(seat, event.clientX, event.clientY, index);
                    
                    // Add document-level drag listener to track cursor position everywhere
                    const onDocumentDrag = (e) => {
                        if (e.clientX !== 0 || e.clientY !== 0) {
                            updateDragClone(e.clientX, e.clientY);
                        }
                    };
                    document.addEventListener('drag', onDocumentDrag);
                    
                    // Clean up on drag end
                    const cleanup = () => {
                        document.removeEventListener('drag', onDocumentDrag);
                        document.removeEventListener('dragend', cleanup);
                    };
                    document.addEventListener('dragend', cleanup);
                };

                const handleDragEnd = () => {
                    dragState.value.dragging = false;
                    dragState.value.fromIndex = null;
                    dragState.value.overIndex = null;
                    removeDragClone();
                };

                const handleDragOver = (index, event) => {
                    event.preventDefault();
                    
                    // Update clone position
                    updateDragClone(event.clientX, event.clientY);
                    
                    const seat = seats.value[index];
                    
                    // Accept both player card drag and next round button drag
                    if (dragState.value.draggingNextRound) {
                        // For next round drag, check if at least one empty seat (allow any position) or if seat is occupied
                        const hasEmptySeat = seats.value.some(s => s === null);
                        if (hasEmptySeat || seat) {
                            dragState.value.overIndex = index;
                            event.dataTransfer.dropEffect = 'move';
                        } else {
                            dragState.value.overIndex = null;
                        }
                    } else {
                        // For player card drag, can't drag to self or empty seat
                        if (!seat || index === dragState.value.fromIndex) {
                            dragState.value.overIndex = null;
                            return;
                        }
                        dragState.value.overIndex = index;
                        event.dataTransfer.dropEffect = 'move';
                    }
                };

                const handleDragLeave = () => {
                    dragState.value.overIndex = null;
                };

                const handleDrop = (toIndex, event) => {
                    event.preventDefault();
                    const fromIndex = parseInt(event.dataTransfer.getData('text/plain'));
                    
                    const fromSeat = seats.value[fromIndex];
                    const toSeat = seats.value[toIndex];
                    
                    if (!fromSeat || !toSeat || fromIndex === toIndex) {
                        handleDragEnd();
                        return;
                    }

                    // Open quick settle modal
                    openQuickSettle(fromSeat, toSeat);
                    handleDragEnd();
                };

                // Touch Events (Mobile)
                const handleTouchStart = (index, event) => {
                    const seat = seats.value[index];
                    if (!seat) return;
                    
                    const touch = event.touches[0];
                    dragState.value.touchStartX = touch.clientX;
                    dragState.value.touchStartY = touch.clientY;
                    dragState.value.fromIndex = index;
                    
                    // Clear any existing timeout
                    if (touchTimeout) clearTimeout(touchTimeout);
                    
                    // Delay to distinguish between tap and drag
                    touchTimeout = setTimeout(() => {
                        // Check if finger hasn't moved much (still holding)
                        dragState.value.dragging = true;
                        // Create clone for touch drag with proper rotation
                        if (!dragClone) {
                            dragClone = createDragClone(seat, dragState.value.touchStartX, dragState.value.touchStartY, index);
                        }
                    }, 150);
                };

                const handleTouchMove = (event) => {
                    const touch = event.touches[0];
                    const dx = Math.abs(touch.clientX - dragState.value.touchStartX);
                    const dy = Math.abs(touch.clientY - dragState.value.touchStartY);
                    
                    // If moved more than 10px, consider it a drag
                    if (dx > 10 || dy > 10) {
                        if (touchTimeout) {
                            clearTimeout(touchTimeout);
                            touchTimeout = null;
                        }
                        dragState.value.dragging = true;
                        
                        // Create clone if not already created with proper rotation
                        if (!dragClone) {
                            const seat = seats.value[dragState.value.fromIndex];
                            if (seat) {
                                dragClone = createDragClone(seat, touch.clientX, touch.clientY, dragState.value.fromIndex);
                            }
                        }
                    }
                    
                    if (!dragState.value.dragging) return;
                    
                    event.preventDefault();
                    
                    // Update clone position
                    updateDragClone(touch.clientX, touch.clientY);
                    
                    // Find which card is under the touch point
                    const element = document.elementFromPoint(touch.clientX, touch.clientY);
                    const card = element?.closest('.player-card');
                    
                    if (card) {
                        // Find the index of this card among all player cards
                        const allCards = document.querySelectorAll('.player-card');
                        const cardIndex = Array.from(allCards).indexOf(card);
                        
                        if (cardIndex !== -1 && cardIndex !== dragState.value.fromIndex) {
                            const seat = seats.value[cardIndex];
                            if (seat) {
                                dragState.value.overIndex = cardIndex;
                            } else {
                                dragState.value.overIndex = null;
                            }
                        }
                    } else {
                        dragState.value.overIndex = null;
                    }
                };

                const handleTouchEnd = (event) => {
                    // Clear timeout if it hasn't fired yet
                    if (touchTimeout) {
                        clearTimeout(touchTimeout);
                        touchTimeout = null;
                    }
                    
                    const wasDragging = dragState.value.dragging;
                    const fromIndex = dragState.value.fromIndex;
                    const toIndex = dragState.value.overIndex;
                    
                    // If was actually dragging and dropped on a valid target
                    if (wasDragging && toIndex !== null && fromIndex !== toIndex) {
                        event.preventDefault(); // Prevent click event
                        
                        const fromSeat = seats.value[fromIndex];
                        const toSeat = seats.value[toIndex];
                        
                        // Reset drag state (will remove clone)
                        handleDragEnd();
                        
                        if (fromSeat && toSeat) {
                            openQuickSettle(fromSeat, toSeat);
                        }
                    } else {
                        // Reset drag state
                        handleDragEnd();
                    }
                };

                // Quick Settle Modal
                const openQuickSettle = (from, to) => {
                    quickSettle.value.from = from;
                    quickSettle.value.to = to;
                    quickSettle.value.amount = '';
                    quickSettle.value.show = true;
                    
                    nextTick(() => {
                        quickAmountInput.value?.focus();
                        quickAmountInput.value?.select();
                    });
                };

                const confirmQuickSettle = () => {
                    const amount = parseInt(quickSettle.value.amount);
                    if (!amount || amount <= 0) return;
                    
                    // Update Scores
                    const fromP = players.value.find(p => p.name === quickSettle.value.from);
                    const toP = players.value.find(p => p.name === quickSettle.value.to);
                    fromP.score -= amount;
                    toP.score += amount;

                    // Record History
                    history.value.unshift({
                        time: Date.now(),
                        round: currentRound.value,
                        dealerIndex: dealerIndex.value,
                        transactions: [{ from: quickSettle.value.from, to: quickSettle.value.to, amount }]
                    });

                    // Show Diff Animation
                    lastDiff.value = {};
                    lastDiff.value[quickSettle.value.from] = -amount;
                    lastDiff.value[quickSettle.value.to] = amount;
                    setTimeout(() => lastDiff.value = {}, 3000);

                    saveState();
                    quickSettle.value.show = false;
                };

                const cancelQuickSettle = () => {
                    quickSettle.value.show = false;
                };

                // Round Management
                const handleNextRoundClick = () => {
                    // Don't trigger click if we just finished dragging
                    if (dragState.value.draggingNextRound) return;
                    
                    // Check if settled this round
                    const settled = history.value.some(h => h.round === currentRound.value);
                    if (!settled && !confirm('æœ¬å±€å°šæœªç»“ç®—ï¼Œç¡®å®šè¿›å…¥ä¸‹ä¸€å±€ï¼Ÿ')) return;
                    
                    // ç›´æ¥æ¢åº„åˆ°ä¸‹ä¸€å®¶
                    dealerIndex.value = (dealerIndex.value + 1) % 4;
                    dealerStreak.value = 0;
                    currentRound.value++;
                    saveState();
                };
                
                const nextRoundCheck = () => {
                    // å·²åºŸå¼ƒï¼Œä¿ç•™å…¼å®¹
                };

                const nextRound = (changeDealer) => {
                    // å·²åºŸå¼ƒï¼Œä¿ç•™å…¼å®¹
                };

                // Settings & Utils
                const closeModal = (name) => modals.value[name] = false;
                const formatTime = (ts) => new Date(ts).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second: '2-digit'});
                
                const clearData = () => {
                    if (confirm('ç¡®å®šæ¸…ç©ºæ‰€æœ‰æ•°æ®ï¼Ÿ')) {
                        localStorage.removeItem('mj_data_v3');
                        location.reload();
                    }
                };

                // Chart
                const showStats = () => {
                    modals.value.stats = true;
                    nextTick(renderChart);
                };

                const renderChart = () => {
                    const ctx = document.getElementById('scoreChart').getContext('2d');
                    if (chartInstance) chartInstance.destroy();

                    // Prepare Data
                    const allNames = players.value.map(p => p.name);
                    
                    // 1. åˆå§‹çŠ¶æ€ (Round 0)
                    const roundSnapshots = new Map(); // round -> scores object
                    roundSnapshots.set(0, Object.fromEntries(allNames.map(n => [n, 0])));
                    
                    // 2. Replay history to build snapshots
                    // å…ˆæŒ‰æ—¶é—´æ’åº
                    const sortedHistory = [...history.value].sort((a, b) => a.time - b.time);
                    
                    // ä¸´æ—¶è®°å½•å½“å‰åˆ†æ•°
                    let currentScores = Object.fromEntries(allNames.map(n => [n, 0]));
                    
                    // éå†æ¯ä¸€æ¡è®°å½•ï¼Œæ›´æ–°å½“å‰åˆ†æ•°ï¼Œå¹¶æ›´æ–°å¯¹åº”å±€æ•°çš„å¿«ç…§
                    // æ³¨æ„ï¼šå¦‚æœåŒä¸€å±€æœ‰å¤šæ¡è®°å½•ï¼Œåé¢çš„ä¼šè¦†ç›–å‰é¢çš„å¿«ç…§ï¼Œè¿™æ˜¯æ­£ç¡®çš„ï¼Œå› ä¸ºæˆ‘ä»¬è¦çš„æ˜¯"è¯¥å±€ç»“æŸæ—¶çš„çŠ¶æ€"
                    sortedHistory.forEach(h => {
                        h.transactions.forEach(t => {
                            if (currentScores[t.from] !== undefined) currentScores[t.from] -= t.amount;
                            if (currentScores[t.to] !== undefined) currentScores[t.to] += t.amount;
                        });
                        // æ›´æ–°è¯¥å±€çš„å¿«ç…§ï¼ˆæ·±æ‹·è´ï¼‰
                        roundSnapshots.set(h.round, { ...currentScores });
                    });

                    // 3. è½¬æ¢ä¸ºæ•°ç»„å¹¶æŒ‰å±€æ•°æ’åº
                    // æ³¨æ„ï¼šå¯èƒ½å­˜åœ¨è·³å±€çš„æƒ…å†µï¼ˆæ¯”å¦‚æ’¤é”€åï¼‰ï¼Œæˆ–è€…ä¸­é—´æŸå±€æ²¡æœ‰è®°å½•ã€‚
                    // Chart.js éœ€è¦è¿ç»­çš„ labels å—ï¼Ÿæœ€å¥½æ˜¯è¿ç»­çš„ã€‚
                    // æˆ‘ä»¬è·å–æœ€å¤§çš„ round
                    const maxRound = Math.max(...roundSnapshots.keys());
                    const labels = [];
                    const dataPoints = [];

                    // å¡«å……æ¯ä¸€å±€çš„æ•°æ®
                    // å¦‚æœæŸå±€æ²¡æœ‰è®°å½•ï¼Œå°±æ²¿ç”¨ä¸Šä¸€å±€çš„æ•°æ®
                    let lastScores = roundSnapshots.get(0);
                    
                    for (let r = 0; r <= maxRound; r++) {
                        labels.push(r === 0 ? 'å¼€å§‹' : `R${r}`);
                        
                        if (roundSnapshots.has(r)) {
                            lastScores = roundSnapshots.get(r);
                        }
                        // å¦‚æœè¿™ä¸€å±€æ²¡æœ‰è®°å½•ï¼ˆæ¯”å¦‚ç›´æ¥è·³åˆ°äº†ä¸‹ä¸€å±€ï¼Œæˆ–è€…è¿˜æ²¡æ‰“å®Œï¼‰ï¼Œæ²¿ç”¨ä¸Šä¸€å±€
                        // ä½†è¿™é‡Œæˆ‘ä»¬åªå±•ç¤º"æœ‰è®°å½•"çš„å±€æ•°ï¼Ÿ
                        // ä¸ï¼Œé€šå¸¸å±•ç¤ºè¿ç»­çš„å±€æ•°æ¯”è¾ƒç›´è§‚ã€‚
                        dataPoints.push(lastScores);
                    }

                    const datasets = allNames.map((name, i) => {
                        const colors = ['#6366f1', '#ec4899', '#10b981', '#f59e0b', '#8b5cf6'];
                        return {
                            label: name,
                            data: dataPoints.map(scores => scores[name] || 0),
                            borderColor: colors[i % colors.length],
                            tension: 0.3,
                            fill: false
                        };
                    });

                    chartInstance = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels,
                            datasets
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { 
                                    labels: { 
                                        color: isDark.value ? '#fff' : '#333',
                                        usePointStyle: true,
                                        pointStyle: 'rect',
                                        padding: 15,
                                        font: {
                                            size: 13
                                        }
                                    },
                                    // å½“åªæœ‰4ä¸ªæˆ–æ›´å°‘ç©å®¶æ—¶ï¼Œä½¿ç”¨2åˆ—å¸ƒå±€
                                    align: 'center',
                                    maxWidth: allNames.length <= 4 ? 500 : 800
                                }
                            },
                            scales: {
                                x: { ticks: { color: isDark.value ? '#aaa' : '#666' }, grid: { color: isDark.value ? '#333' : '#ddd' } },
                                y: { 
                                    ticks: { 
                                        color: isDark.value ? '#aaa' : '#666',
                                        // åªæ˜¾ç¤ºæ•´æ•°ï¼Œä¸æ˜¾ç¤ºå°æ•°
                                        callback: function(value) {
                                            if (Math.floor(value) === value) {
                                                return value;
                                            }
                                        }
                                    }, 
                                    grid: { color: isDark.value ? '#333' : '#ddd' } 
                                }
                            }
                        }
                    });
                };

                // Wake Lock
                const requestWakeLock = async () => {
                    try {
                        if ('wakeLock' in navigator) {
                            await navigator.wakeLock.request('screen');
                        }
                    } catch (e) { console.log(e); }
                };
                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'visible') requestWakeLock();
                });

                return {
                    isDark, toggleTheme,
                    seats, players, currentRound, dealerIndex, dealerStreak, history, lastDiff,
                    modals, closeModal,
                    activePlayers, availablePlayers, dialRotation,
                    getPlayerScore, handleSeatClick, addNewPlayer, sitDown, newPlayerName,
                    openSettleModal, settleFrom, settleTo, settleAmount, selectingFrom, selectSettlePlayer, confirmSettle, amountInput,
                    undo, handleNextRoundClick, nextRoundCheck, nextRound,
                    formatTime, clearData,
                    showStats, showHistory: () => modals.value.history = true, showSettings: () => modals.value.settings = true, showRoundModal: () => {},
                    // Drag and Drop (Player Cards)
                    dragState,
                    handleDragStart, handleDragEnd, handleDragOver, handleDragLeave, handleDrop,
                    handleTouchStart, handleTouchMove, handleTouchEnd,
                    // Drag and Drop (Next Round Button)
                    handleNextRoundDragStart, handleNextRoundDragEnd,
                    handleNextRoundTouchStart, handleNextRoundTouchMove, handleNextRoundTouchEnd,
                    // Quick Settle
                    quickSettle, quickAmountInput, confirmQuickSettle, cancelQuickSettle,
                    
                    // Dice
                    diceMode, isRolling, hasRolled, diceStyles, handleDialClick, closeDiceMode
                };
            }
        }).mount('#app');
    </script>
</body>
</html>