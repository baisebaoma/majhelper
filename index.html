<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>麻将记分 Pro</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #ec4899;
            --bg-light: #f3f4f6;
            --bg-dark: #111827;
            --card-light: rgba(255, 255, 255, 0.8);
            --card-dark: rgba(31, 41, 55, 0.8);
            --text-light: #1f2937;
            --text-dark: #f9fafb;
            --danger: #ef4444;
            --success: #10b981;
            --warning: #f59e0b;
        }

        /* 基础重置 */
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            /* 移除 body 的默认背景，交给 #app 接管，或者设为透明 */
            background: #000; 
            color: var(--text-light);
            transition: color 0.3s;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }
        body.dark {
            color: var(--text-dark);
        }

        /* 布局容器 */
        #app {
            display: flex;
            flex-direction: column;
            height: 100%;
            max-width: 100%;
            margin: 0 auto;
            position: relative;
            /* 默认背景色在这里定义 */
            background: #007b43;
            transition: background 0.3s;
            background-size: cover;
            background-position: center;
        }
        #app.dark {
            background: var(--bg-dark);
        }

        /* 顶部栏 */
        .header {
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255,255,255,0.5);
            backdrop-filter: blur(10px);
            z-index: 10;
        }
        body.dark .header { background: rgba(0,0,0,0.3); }

        .round-badge {
            background: var(--primary);
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 14px;
            box-shadow: 0 4px 6px -1px rgba(99, 102, 241, 0.4);
            cursor: pointer;
        }

        .header-actions { display: flex; gap: 12px; }
        .icon-btn {
            background: none;
            border: none;
            font-size: 20px;
            color: inherit;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: background 0.2s;
        }
        .icon-btn:hover { background: rgba(0,0,0,0.05); }
        body.dark .icon-btn:hover { background: rgba(255,255,255,0.1); }

        /* 游戏区域 */
        .game-area {
            flex: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        /* 中间转盘 */
        .center-dial {
            position: absolute;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: var(--card-light);
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 5;
            transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
            border: 4px solid rgba(255,255,255,0.5);
        }
        body.dark .center-dial {
            background: var(--card-dark);
            border-color: rgba(255,255,255,0.1);
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.5);
        }

        .dial-round { 
            font-size: 36px; /* 缩小字号 */
            font-weight: 800; 
            color: var(--primary); 
            line-height: 1;
        }
        
        /* 方向指示 */
        .direction {
            position: absolute;
            font-size: 20px; /* 稍微缩小方向字号 */
            font-weight: bold;
            color: #9ca3af;
            transition: color 0.3s;
        }
        /* 只有东(0)是红色，其他默认 */
        .direction.is-east { color: var(--danger); text-shadow: 0 0 10px rgba(239, 68, 68, 0.5); }
        
        /* 增加边距，往外移 */
        .dir-0 { bottom: 10px; } 
        .dir-1 { right: 10px; transform: rotate(-90deg); } 
        .dir-2 { top: 10px; transform: rotate(180deg); } 
        .dir-3 { left: 10px; transform: rotate(90deg); }

        /* 玩家卡片 */
        .player-card {
            position: absolute;
            width: 160px;
            padding: 16px;
            background: var(--card-light);
            backdrop-filter: blur(12px);
            border-radius: 20px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            border: 2px solid transparent;
        }
        body.dark .player-card { background: var(--card-dark); box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3); }

        /* 针对不同座位的旋转 */
        .pos-1 { transform: translateY(-50%) rotate(-90deg); }
        .pos-2 { transform: rotate(180deg); }
        .pos-3 { transform: translateY(-50%) rotate(90deg); }

        /* 激活状态需要叠加旋转 */
        .player-card.active.pos-0 { transform: scale(1.05); }
        .player-card.active.pos-1 { transform: translateY(-50%) rotate(-90deg) scale(1.05); }
        .player-card.active.pos-2 { transform: rotate(180deg) scale(1.05); }
        .player-card.active.pos-3 { transform: translateY(-50%) rotate(90deg) scale(1.05); }
        
        .player-card.dealer { border-color: var(--danger); }
        .player-card.dealer::before {
            content: '庄';
            position: absolute;
            top: -10px;
            right: -10px;
            width: 24px;
            height: 24px;
            background: var(--danger);
            color: white;
            border-radius: 50%;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 2;
        }

        /* 响应式定位修正 */
        .pos-0 { bottom: 20px; }
        .pos-1 { right: -20px; top: 50%; } /* 右侧稍微靠外一点，因为旋转了 */
        .pos-2 { top: 80px; } 
        .pos-3 { left: -20px; top: 50%; } /* 左侧稍微靠外一点 */

        /* 强制竖屏逻辑 */
        @media screen and (orientation: landscape) {
            body {
                display: flex;
                align-items: center;
                justify-content: center;
                background: #000; /* 横屏时背景变黑，突出中间的内容 */
            }
            
            #app {
                /* 强制旋转90度 */
            transform: rotate(-90deg);
                transform-origin: center;
                /* 交换宽高：宽度变成屏幕高度，高度变成屏幕宽度 */
                width: 100vh;
                height: 100vw;
                /* 重新定位 */
                position: absolute;
                overflow: hidden;
                background: var(--bg-light); /* 恢复应用背景色 */
            }
            
            body.dark #app {
                background: var(--bg-dark);
            }
            
            /* 修复旋转后的模态框方向，让它们看起来是正的 */
            /* 实际上模态框是在 #app 内部的，所以它们会跟着 #app 一起转，
               对于用户来说，手机横着拿，看到的画面就是竖着的，所以不需要额外处理模态框。
               用户需要把手机竖过来（或者头歪过来）操作，这正是我们想要的效果。
            */
        }

        .player-name { font-size: 16px; font-weight: 600; margin-bottom: 4px; opacity: 0.8; }
        .player-score { font-size: 28px; font-weight: 800; color: var(--primary); }
        .score-diff { font-size: 12px; height: 16px; font-weight: bold; }
        .diff-pos { color: var(--success); }
        .diff-neg { color: var(--danger); }

        /* 底部操作栏 */
        .action-bar {
            padding: 20px;
            display: flex;
            gap: 12px;
            justify-content: center;
            background: rgba(255,255,255,0.5);
            backdrop-filter: blur(10px);
            z-index: 10;
        }
        body.dark .action-bar { background: rgba(0,0,0,0.3); }

        .btn {
            padding: 12px 24px;
            border-radius: 12px;
            border: none;
            font-weight: 600;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .btn:active { transform: scale(0.96); }
        
        .btn-primary { background: var(--primary); color: white; }
        .btn-primary:hover { background: var(--primary-dark); }
        .btn-secondary { background: white; color: var(--text-light); }
        body.dark .btn-secondary { background: var(--card-dark); color: var(--text-dark); }
        .btn-danger { background: var(--danger); color: white; }
        .btn-warning { background: var(--warning); color: white; }

        /* 模态框 */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(4px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        .modal-overlay.show { opacity: 1; pointer-events: auto; }

        .modal-card {
            background: white;
            width: 90%;
            max-width: 400px;
            border-radius: 24px;
            padding: 24px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
            transform: translateY(20px);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            max-height: 85vh;
            overflow-y: auto;
        }
        body.dark .modal-card { background: #1f2937; border: 1px solid rgba(255,255,255,0.1); }
        .modal-overlay.show .modal-card { transform: translateY(0); }

        .modal-title { font-size: 20px; font-weight: 800; margin-bottom: 20px; text-align: center; }
        
        /* 输入框 */
        .input-field {
            width: 100%;
            padding: 12px 16px;
            border-radius: 12px;
            border: 2px solid #e5e7eb;
            background: #f9fafb;
            font-size: 16px;
            margin-bottom: 16px;
            transition: border-color 0.2s;
        }
        body.dark .input-field { background: #374151; border-color: #4b5563; color: white; }
        .input-field:focus { outline: none; border-color: var(--primary); }

        /* 列表项 */
        .list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            border-radius: 12px;
            background: #f3f4f6;
            margin-bottom: 8px;
            cursor: pointer;
        }
        body.dark .list-item { background: #374151; }
        .list-item.active { background: var(--primary); color: white; }

        /* 动画 */
        .fade-enter-active, .fade-leave-active { transition: opacity 0.3s; }
        .fade-enter-from, .fade-leave-to { opacity: 0; }
        
        .slide-up-enter-active, .slide-up-leave-active { transition: all 0.3s; }
        .slide-up-enter-from, .slide-up-leave-to { transform: translateY(100%); opacity: 0; }

        /* 结算选择器 */
        .settle-grid {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 10px;
            align-items: center;
            margin-bottom: 20px;
        }
        .player-select-box {
            padding: 10px;
            border-radius: 12px;
            background: #f3f4f6;
            text-align: center;
            cursor: pointer;
            border: 2px solid transparent;
        }
        body.dark .player-select-box { background: #374151; }
        .player-select-box.selected { border-color: var(--primary); background: rgba(99, 102, 241, 0.1); }
        .arrow-icon { color: var(--text-light); opacity: 0.5; }
        body.dark .arrow-icon { color: var(--text-dark); }

        /* 历史记录 */
        .history-item {
            border-left: 3px solid var(--primary);
            padding-left: 12px;
            margin-bottom: 16px;
        }
        .history-meta { font-size: 12px; opacity: 0.6; margin-bottom: 4px; display: flex; justify-content: space-between; }
        .history-trans { font-size: 14px; margin-bottom: 2px; }
        .trans-amount { font-weight: bold; color: var(--primary); }

        /* 统计图表容器 */
        .chart-container { position: relative; height: 300px; width: 100%; }
    </style>
</head>
<body>
    <div id="app" :class="{ dark: isDark }">
        <!-- 顶部栏 -->
        <header class="header">
            <div class="round-badge" @click="showRoundModal">
                第 {{ currentRound }} 局
            </div>
            <div class="header-actions">
                <button class="icon-btn" @click="toggleTheme">
                    <i class="fas" :class="isDark ? 'fa-sun' : 'fa-moon'"></i>
                </button>
                <button class="icon-btn" @click="showStats">
                    <i class="fas fa-chart-line"></i>
                </button>
                <button class="icon-btn" @click="showHistory">
                    <i class="fas fa-history"></i>
                </button>
                <button class="icon-btn" @click="showSettings">
                    <i class="fas fa-cog"></i>
                </button>
            </div>
        </header>

        <!-- 游戏主区域 -->
        <main class="game-area">
            <!-- 中间转盘 -->
            <div class="center-dial" :style="{ transform: `rotate(${dialRotation}deg)` }">
                <!-- 只有当该方向对应的是东(dealerIndex)时才高亮 -->
                <div class="direction dir-0 is-east">東</div>
                <div class="direction dir-1">南</div>
                <div class="direction dir-2">西</div>
                <div class="direction dir-3">北</div>
                
                <!-- 数字直接显示，跟随父容器旋转，正对庄家 -->
                <div class="dial-round">{{ currentRound }}</div>
            </div>

            <!-- 玩家卡片 -->
            <div v-for="(seat, index) in seats" :key="index" 
                 class="player-card" 
                 :class="[`pos-${index}`, { dealer: dealerIndex === index }]"
                 @click="handleSeatClick(index)">
                <div v-if="seat" style="width: 100%; text-align: center;">
                    <div class="player-name">{{ seat }}</div>
                    <div class="player-score">
                        <count-up :to="getPlayerScore(seat)"></count-up>
                    </div>
                    <div class="score-diff">
                        <span v-if="lastDiff[seat]" :class="lastDiff[seat] > 0 ? 'diff-pos' : 'diff-neg'">
                            {{ lastDiff[seat] > 0 ? '+' : '' }}{{ lastDiff[seat] }}
                        </span>
                    </div>
                </div>
                <div v-else style="opacity: 0.5; font-style: italic;">
                    <i class="fas fa-plus-circle" style="margin-bottom: 8px; font-size: 24px;"></i>
                    <div>入座</div>
                </div>
            </div>
        </main>

        <!-- 底部操作栏 -->
        <footer class="action-bar">
            <button class="btn btn-warning" @click="undo" :disabled="history.length === 0" :style="{ opacity: history.length ? 1 : 0.5 }">
                <i class="fas fa-undo"></i> 撤销
            </button>
            <button class="btn btn-primary" @click="openSettleModal" style="flex: 1; justify-content: center;">
                <i class="fas fa-coins"></i> 结算
            </button>
            <button class="btn btn-secondary" @click="nextRoundCheck">
                下一局 <i class="fas fa-chevron-right"></i>
            </button>
        </footer>

        <!-- 模态框组件 -->
        
        <!-- 1. 结算模态框 -->
        <div class="modal-overlay" :class="{ show: modals.settle }">
            <div class="modal-card">
                <div class="modal-title">结算分数</div>
                
                <div class="settle-grid">
                    <div class="player-select-box" :class="{ selected: settleFrom }" @click="selectingFrom = true">
                        {{ settleFrom || '谁给钱?' }}
                    </div>
                    <i class="fas fa-arrow-right arrow-icon"></i>
                    <div class="player-select-box" :class="{ selected: settleTo }" @click="selectingFrom = false">
                        {{ settleTo || '给谁?' }}
                    </div>
                </div>

                <!-- 玩家选择列表 -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 20px;">
                    <div v-for="p in activePlayers" :key="p" 
                         class="list-item" 
                         :class="{ active: (selectingFrom ? settleFrom : settleTo) === p }"
                         style="justify-content: center; margin: 0;"
                         @click="selectSettlePlayer(p)">
                        {{ p }}
                    </div>
                </div>

                <div class="input-group">
                    <input type="number" v-model.number="settleAmount" class="input-field" placeholder="输入金额" ref="amountInput">
                </div>

                <div style="display: flex; gap: 10px;">
                    <button class="btn btn-secondary" style="flex: 1;" @click="closeModal('settle')">取消</button>
                    <button class="btn btn-primary" style="flex: 1;" @click="confirmSettle">确认</button>
                </div>
            </div>
        </div>

        <!-- 2. 选人入座模态框 -->
        <div class="modal-overlay" :class="{ show: modals.seat }">
            <div class="modal-card">
                <div class="modal-title">选择玩家入座</div>
                <div class="input-field" style="display: flex; gap: 8px; padding: 4px; border: none; background: transparent;">
                    <input v-model="newPlayerName" class="input-field" placeholder="新玩家名字" style="margin: 0;">
                    <button class="btn btn-primary" @click="addNewPlayer" style="padding: 0 16px;">
                        <i class="fas fa-plus"></i>
                    </button>
                </div>
                <div style="max-height: 300px; overflow-y: auto;">
                    <div v-for="p in availablePlayers" :key="p.name" class="list-item" @click="sitDown(p.name)">
                        <span>{{ p.name }}</span>
                        <span style="font-weight: bold;">{{ p.score }}</span>
                    </div>
                </div>
                <button class="btn btn-secondary" style="width: 100%; margin-top: 16px;" @click="closeModal('seat')">取消</button>
            </div>
        </div>

        <!-- 3. 下一局确认模态框 -->
        <div class="modal-overlay" :class="{ show: modals.nextRound }">
            <div class="modal-card">
                <div class="modal-title">进入下一局</div>
                <p style="text-align: center; margin-bottom: 20px; opacity: 0.7;">庄家如何变动？</p>
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    <button class="btn btn-secondary" @click="nextRound(true)">
                        <i class="fas fa-exchange-alt"></i> 换庄 (下家做庄)
                    </button>
                    <button class="btn btn-warning" @click="nextRound(false)">
                        <i class="fas fa-redo"></i> 连庄 (庄家继续)
                    </button>
                    <button class="btn btn-secondary" style="margin-top: 10px;" @click="closeModal('nextRound')">取消</button>
                </div>
            </div>
        </div>

        <!-- 4. 历史记录模态框 -->
        <div class="modal-overlay" :class="{ show: modals.history }">
            <div class="modal-card">
                <div class="modal-title">历史记录</div>
                <div v-if="history.length === 0" style="text-align: center; opacity: 0.5; padding: 20px;">暂无记录</div>
                <div v-else style="max-height: 400px; overflow-y: auto;">
                    <div v-for="(h, i) in history" :key="i" class="history-item">
                        <div class="history-meta">
                            <span>第 {{ h.round }} 局</span>
                            <span>{{ formatTime(h.time) }}</span>
                        </div>
                        <div v-for="(t, ti) in h.transactions" :key="ti" class="history-trans">
                            {{ t.from }} <i class="fas fa-arrow-right" style="font-size: 10px; opacity: 0.5;"></i> {{ t.to }} : 
                            <span class="trans-amount">{{ t.amount }}</span>
                        </div>
                    </div>
                </div>
                <button class="btn btn-secondary" style="width: 100%; margin-top: 16px;" @click="closeModal('history')">关闭</button>
            </div>
        </div>

        <!-- 5. 统计图表模态框 -->
        <div class="modal-overlay" :class="{ show: modals.stats }">
            <div class="modal-card" style="max-width: 600px; width: 95%;">
                <div class="modal-title">分数走势</div>
                <div class="chart-container">
                    <canvas id="scoreChart"></canvas>
                </div>
                <button class="btn btn-secondary" style="width: 100%; margin-top: 16px;" @click="closeModal('stats')">关闭</button>
            </div>
        </div>

        <!-- 6. 设置模态框 -->
        <div class="modal-overlay" :class="{ show: modals.settings }">
            <div class="modal-card">
                <div class="modal-title">设置</div>
                
                <div class="list-item" @click="clearData" style="color: var(--danger);">
                    <span><i class="fas fa-trash-alt" style="margin-right: 8px;"></i> 清空所有数据</span>
                </div>
                <button class="btn btn-secondary" style="width: 100%; margin-top: 16px;" @click="closeModal('settings')">关闭</button>
            </div>
        </div>

        <!-- 7. 手动调庄模态框 -->
        <div class="modal-overlay" :class="{ show: modals.dealerSet }">
            <div class="modal-card">
                <div class="modal-title">指定庄家</div>
                <!-- Vue 3 fix: v-if has higher priority than v-for, so we cannot use seat in v-if on the same element -->
                <template v-for="(s, i) in seats" :key="i">
                    <div v-if="s"
                         class="list-item" 
                         :class="{ active: dealerIndex === i }"
                         @click="setDealer(i)">
                        <span>{{ s }}</span>
                        <span v-if="dealerIndex === i"><i class="fas fa-check"></i></span>
                    </div>
                </template>
                <button class="btn btn-secondary" style="width: 100%; margin-top: 16px;" @click="closeModal('dealerSet')">取消</button>
            </div>
        </div>

    </div>

    <script>
        const { createApp, ref, computed, onMounted, watch, nextTick } = Vue;

        // 数字滚动组件
        const CountUp = {
            props: ['to'],
            template: '<span>{{ displayValue }}</span>',
            setup(props) {
                const displayValue = ref(props.to);
                let animationFrame;

                watch(() => props.to, (newVal, oldVal) => {
                    const start = oldVal || 0;
                    const end = newVal;
                    const duration = 1000;
                    let startTime = null;

                    const animate = (timestamp) => {
                        if (!startTime) startTime = timestamp;
                        const progress = Math.min((timestamp - startTime) / duration, 1);
                        const ease = 1 - Math.pow(1 - progress, 4); // easeOutQuart
                        displayValue.value = Math.floor(progress * (end - start) + start);

                        if (progress < 1) {
                            animationFrame = requestAnimationFrame(animate);
                        } else {
                            displayValue.value = end;
                        }
                    };
                    cancelAnimationFrame(animationFrame);
                    animationFrame = requestAnimationFrame(animate);
                });

                return { displayValue };
            }
        };

        createApp({
            components: { CountUp },
            setup() {
                // --- State ---
                const isDark = ref(false);
                const players = ref([]); // { name, score }
                const seats = ref([null, null, null, null]); // names
                const currentRound = ref(1);
                const dealerIndex = ref(0);
                const history = ref([]);
                const lastDiff = ref({}); // { name: diff } for animation
                
                // UI State
                const modals = ref({
                    settle: false,
                    seat: false,
                    nextRound: false,
                    history: false,
                    stats: false,
                    settings: false,
                    dealerSet: false
                });
                
                const activeSeatIndex = ref(null);
                const newPlayerName = ref('');
                
                // Settle State
                const settleFrom = ref(null);
                const settleTo = ref(null);
                const settleAmount = ref('');
                const selectingFrom = ref(true);
                const amountInput = ref(null);

                // Chart
                let chartInstance = null;

                // --- Computed ---
                const activePlayers = computed(() => seats.value.filter(n => n));
                const availablePlayers = computed(() => players.value.filter(p => !seats.value.includes(p.name)));
                const dialRotation = computed(() => {
                    // 0(Bottom) -> 0deg
                    // 1(Right) -> -90deg
                    // 2(Top) -> 180deg
                    // 3(Left) -> 90deg
                    const rots = [0, -90, 180, 90];
                    return rots[dealerIndex.value];
                });
                
                // --- Methods ---
                
                // Init
                onMounted(() => {
                    loadState();
                    initTheme();
                    requestWakeLock();
                });

                // Theme
                const toggleTheme = () => {
                    isDark.value = !isDark.value;
                    localStorage.setItem('mj_theme', isDark.value ? 'dark' : 'light');
                    if (isDark.value) document.body.classList.add('dark');
                    else document.body.classList.remove('dark');
                };

                const initTheme = () => {
                    const saved = localStorage.getItem('mj_theme');
                    if (saved) {
                        isDark.value = saved === 'dark';
                    } else {
                        isDark.value = window.matchMedia('(prefers-color-scheme: dark)').matches;
                    }
                    if (isDark.value) document.body.classList.add('dark');
                };

                // Data Persistence
                const saveState = () => {
                    const state = {
                        players: players.value,
                        seats: seats.value,
                        currentRound: currentRound.value,
                        dealerIndex: dealerIndex.value,
                        history: history.value
                    };
                    localStorage.setItem('mj_data_v3', JSON.stringify(state));
                };

                const loadState = () => {
                    const saved = localStorage.getItem('mj_data_v3');
                    if (saved) {
                        const data = JSON.parse(saved);
                        players.value = data.players || [];
                        seats.value = data.seats || [null, null, null, null];
                        currentRound.value = data.currentRound || 1;
                        dealerIndex.value = data.dealerIndex || 0;
                        history.value = data.history || [];
                    }
                };

                // Player Management
                const getPlayerScore = (name) => {
                    const p = players.value.find(p => p.name === name);
                    return p ? p.score : 0;
                };

                const handleSeatClick = (index) => {
                    activeSeatIndex.value = index;
                    modals.value.seat = true;
                };

                const addNewPlayer = () => {
                    const name = newPlayerName.value.trim();
                    if (!name) return;
                    if (players.value.some(p => p.name === name)) return alert('玩家已存在');
                    players.value.push({ name, score: 0 });
                    newPlayerName.value = '';
                    saveState();
                };

                const sitDown = (name) => {
                    seats.value[activeSeatIndex.value] = name;
                    closeModal('seat');
                    saveState();
                };

                // Settlement
                const openSettleModal = () => {
                    if (activePlayers.value.length < 2) return alert('请先设置至少2名玩家');
                    settleFrom.value = null;
                    settleTo.value = null;
                    settleAmount.value = '';
                    selectingFrom.value = true;
                    modals.value.settle = true;
                };

                const selectSettlePlayer = (name) => {
                    if (selectingFrom.value) {
                        if (settleTo.value === name) settleTo.value = null; // Swap prevention
                        settleFrom.value = name;
                        selectingFrom.value = false; // Auto advance
                    } else {
                        if (settleFrom.value === name) settleFrom.value = null;
                        settleTo.value = name;
                        // Focus input
                        nextTick(() => amountInput.value?.focus());
                    }
                };

                const confirmSettle = () => {
                    if (!settleFrom.value || !settleTo.value || !settleAmount.value) return;
                    const amount = parseInt(settleAmount.value);
                    if (amount <= 0) return;

                    // Update Scores
                    const fromP = players.value.find(p => p.name === settleFrom.value);
                    const toP = players.value.find(p => p.name === settleTo.value);
                    fromP.score -= amount;
                    toP.score += amount;

                    // Record History
                    history.value.unshift({
                        time: Date.now(),
                        round: currentRound.value,
                        dealerIndex: dealerIndex.value,
                        transactions: [{ from: settleFrom.value, to: settleTo.value, amount }]
                    });

                    // Show Diff Animation
                    lastDiff.value = {};
                    lastDiff.value[settleFrom.value] = -amount;
                    lastDiff.value[settleTo.value] = amount;
                    setTimeout(() => lastDiff.value = {}, 3000);

                    saveState();
                    closeModal('settle');
                };

                const undo = () => {
                    if (history.value.length === 0) return;
                    if (!confirm('确定撤销上一次结算？')) return;

                    const last = history.value.shift();
                    last.transactions.forEach(t => {
                        const fromP = players.value.find(p => p.name === t.from);
                        const toP = players.value.find(p => p.name === t.to);
                        if (fromP) fromP.score += t.amount;
                        if (toP) toP.score -= t.amount;
                    });
                    saveState();
                };

                // Round Management
                const nextRoundCheck = () => {
                    // Check if settled this round
                    const settled = history.value.some(h => h.round === currentRound.value);
                    if (!settled && !confirm('本局尚未结算，确定进入下一局？')) return;
                    modals.value.nextRound = true;
                };

                const nextRound = (changeDealer) => {
                    if (changeDealer) {
                        dealerIndex.value = (dealerIndex.value + 1) % 4;
                    }
                    currentRound.value++;
                    saveState();
                    closeModal('nextRound');
                };

                // Settings & Utils
                const closeModal = (name) => modals.value[name] = false;
                const formatTime = (ts) => new Date(ts).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                
                const clearData = () => {
                    if (confirm('确定清空所有数据？')) {
                        localStorage.removeItem('mj_data_v3');
                        location.reload();
                    }
                };

                // Chart
                const showStats = () => {
                    modals.value.stats = true;
                    nextTick(renderChart);
                };

                const renderChart = () => {
                    const ctx = document.getElementById('scoreChart').getContext('2d');
                    if (chartInstance) chartInstance.destroy();

                    // Prepare Data
                    const allNames = players.value.map(p => p.name);
                    
                    // 1. 初始状态 (Round 0)
                    const roundSnapshots = new Map(); // round -> scores object
                    roundSnapshots.set(0, Object.fromEntries(allNames.map(n => [n, 0])));
                    
                    // 2. Replay history to build snapshots
                    // 先按时间排序
                    const sortedHistory = [...history.value].sort((a, b) => a.time - b.time);
                    
                    // 临时记录当前分数
                    let currentScores = Object.fromEntries(allNames.map(n => [n, 0]));
                    
                    // 遍历每一条记录，更新当前分数，并更新对应局数的快照
                    // 注意：如果同一局有多条记录，后面的会覆盖前面的快照，这是正确的，因为我们要的是"该局结束时的状态"
                    sortedHistory.forEach(h => {
                        h.transactions.forEach(t => {
                            if (currentScores[t.from] !== undefined) currentScores[t.from] -= t.amount;
                            if (currentScores[t.to] !== undefined) currentScores[t.to] += t.amount;
                        });
                        // 更新该局的快照（深拷贝）
                        roundSnapshots.set(h.round, { ...currentScores });
                    });

                    // 3. 转换为数组并按局数排序
                    // 注意：可能存在跳局的情况（比如撤销后），或者中间某局没有记录。
                    // Chart.js 需要连续的 labels 吗？最好是连续的。
                    // 我们获取最大的 round
                    const maxRound = Math.max(...roundSnapshots.keys());
                    const labels = [];
                    const dataPoints = [];

                    // 填充每一局的数据
                    // 如果某局没有记录，就沿用上一局的数据
                    let lastScores = roundSnapshots.get(0);
                    
                    for (let r = 0; r <= maxRound; r++) {
                        labels.push(r === 0 ? '开始' : `R${r}`);
                        
                        if (roundSnapshots.has(r)) {
                            lastScores = roundSnapshots.get(r);
                        }
                        // 如果这一局没有记录（比如直接跳到了下一局，或者还没打完），沿用上一局
                        // 但这里我们只展示"有记录"的局数？
                        // 不，通常展示连续的局数比较直观。
                        dataPoints.push(lastScores);
                    }

                    const datasets = allNames.map((name, i) => {
                        const colors = ['#6366f1', '#ec4899', '#10b981', '#f59e0b', '#8b5cf6'];
                        return {
                            label: name,
                            data: dataPoints.map(scores => scores[name] || 0),
                            borderColor: colors[i % colors.length],
                            tension: 0.3,
                            fill: false
                        };
                    });

                    chartInstance = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels,
                            datasets
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { labels: { color: isDark.value ? '#fff' : '#333' } }
                            },
                            scales: {
                                x: { ticks: { color: isDark.value ? '#aaa' : '#666' }, grid: { color: isDark.value ? '#333' : '#ddd' } },
                                y: { ticks: { color: isDark.value ? '#aaa' : '#666' }, grid: { color: isDark.value ? '#333' : '#ddd' } }
                            }
                        }
                    });
                };

                // Wake Lock
                const requestWakeLock = async () => {
                    try {
                        if ('wakeLock' in navigator) {
                            await navigator.wakeLock.request('screen');
                        }
                    } catch (e) { console.log(e); }
                };
                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'visible') requestWakeLock();
                });

                return {
                    isDark, toggleTheme,
                    seats, players, currentRound, dealerIndex, history, lastDiff,
                    modals, closeModal,
                    activePlayers, availablePlayers, dialRotation,
                    getPlayerScore, handleSeatClick, addNewPlayer, sitDown, newPlayerName,
                    openSettleModal, settleFrom, settleTo, settleAmount, selectingFrom, selectSettlePlayer, confirmSettle, amountInput,
                    undo, nextRoundCheck, nextRound,
                    formatTime, clearData,
                    showStats, showHistory: () => modals.value.history = true, showSettings: () => modals.value.settings = true, showRoundModal: () => {}
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
